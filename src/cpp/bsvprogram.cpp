#include "common.h"
#include "bsvprogram.h"
#include <cstdarg>
#include <cstdio>
#include <sstream>

namespace SV {

void SVCodeGen::emitHeader(CodeBuilder* builder, const std::string& moduleName) {
    builder->appendLine("//");
    builder->appendLine("// SystemVerilog Module: " + moduleName);
    builder->appendLine("// Generated by P4-to-SV Compiler");
    builder->appendLine("//");
    builder->newline();
}

void SVCodeGen::emitAxiStreamInterface(CodeBuilder* builder, 
                                       const std::string& name, 
                                       bool isMaster) {
    if (isMaster) {
        builder->appendLine("// AXI-Stream Master Interface: " + name);
        builder->appendLine("output logic [511:0] " + name + "_tdata,");
        builder->appendLine("output logic [63:0]  " + name + "_tkeep,");
        builder->appendLine("output logic         " + name + "_tvalid,");
        builder->appendLine("input  logic         " + name + "_tready,");
        builder->appendLine("output logic         " + name + "_tlast,");
    } else {
        builder->appendLine("// AXI-Stream Slave Interface: " + name);
        builder->appendLine("input  logic [511:0] " + name + "_tdata,");
        builder->appendLine("input  logic [63:0]  " + name + "_tkeep,");
        builder->appendLine("input  logic         " + name + "_tvalid,");
        builder->appendLine("output logic         " + name + "_tready,");
        builder->appendLine("input  logic         " + name + "_tlast,");
    }
}

void SVCodeGen::emitPipelineStage(CodeBuilder* builder, int stage) {
    std::stringstream ss;
    
    // Pipeline stage register
    ss.str("");
    ss << "// Pipeline stage " << stage;
    builder->appendLine(ss.str());
    
    ss.str("");
    ss << "always_ff @(posedge clk) begin";
    builder->appendLine(ss.str());
    builder->increaseIndent();
    
    builder->appendLine("if (!rst_n) begin");
    builder->increaseIndent();
    
    ss.str("");
    ss << "stage" << stage << "_valid <= 1'b0;";
    builder->appendLine(ss.str());
    
    builder->decreaseIndent();
    builder->appendLine("end else begin");
    builder->increaseIndent();
    
    ss.str("");
    ss << "stage" << stage << "_valid <= stage" << (stage-1) << "_valid;";
    builder->appendLine(ss.str());
    
    ss.str("");
    ss << "stage" << stage << "_data <= stage" << (stage-1) << "_data;";
    builder->appendLine(ss.str());
    
    builder->decreaseIndent();
    builder->appendLine("end");
    
    builder->decreaseIndent();
    builder->appendLine("end");
}

std::string SVCodeGen::getMakefile() const {
    std::stringstream make;
    make << "# Makefile for SystemVerilog simulation\n";
    make << "TOP = top\n";
    make << "SRC = $(wildcard *.sv) $(wildcard *.svh)\n";
    make << "\n";
    make << "# Default simulator: Xilinx Vivado xsim\n";
    make << "sim: $(SRC)\n";
    make << "\txvlog $(SRC)\n";
    make << "\txelab $(TOP) -s $(TOP)_sim\n";
    make << "\txsim $(TOP)_sim -runall\n";
    make << "\n";
    make << "# Alternative: ModelSim/QuestaSim\n";
    make << "vsim: $(SRC)\n";
    make << "\tvlog $(SRC)\n";
    make << "\tvsim -c $(TOP) -do \"run -all; quit\"\n";
    make << "\n";
    make << "# Alternative: Icarus Verilog\n";
    make << "iverilog: $(SRC)\n";
    make << "\tiverilog -g2012 -o $(TOP).vvp $(SRC)\n";
    make << "\tvvp $(TOP).vvp\n";
    make << "\n";
    make << "clean:\n";
    make << "\trm -rf xsim.dir *.log *.pb *.jou *.vvp *.vcd work/\n";
    make << "\n";
    make << ".PHONY: sim vsim iverilog clean\n";
    
    return make.str();
}

std::string SVCodeGen::getTestbench() const {
    std::stringstream tb;
    tb << "// Testbench for P4-generated SystemVerilog\n";
    tb << "`timescale 1ns/1ps\n";
    tb << "\n";
    tb << "module testbench();\n";
    tb << "    logic clk = 0;\n";
    tb << "    logic rst_n = 0;\n";
    tb << "    \n";
    tb << "    // Clock generation\n";
    tb << "    always #5 clk = ~clk;\n";
    tb << "    \n";
    tb << "    // Reset sequence\n";
    tb << "    initial begin\n";
    tb << "        #100 rst_n = 1;\n";
    tb << "    end\n";
    tb << "    \n";
    tb << "    // DUT instantiation\n";
    tb << "    top dut (\n";
    tb << "        .clk(clk),\n";
    tb << "        .rst_n(rst_n)\n";
    tb << "    );\n";
    tb << "    \n";
    tb << "    // Test sequence\n";
    tb << "    initial begin\n";
    tb << "        $dumpfile(\"waveform.vcd\");\n";
    tb << "        $dumpvars(0, testbench);\n";
    tb << "        #10000 $finish;\n";
    tb << "    end\n";
    tb << "endmodule\n";
    
    return tb.str();
}

}  // namespace SV