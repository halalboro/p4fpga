/**
 * {{MODULE_NAME}} Control Slave
 * Generated by POS Compiler
 * 
 * Converts AXI-Lite slave interface to simple table write signals
 */

import lynxTypes::*;

module {{MODULE_NAME}}_slave (
    input  logic                          aclk,
    input  logic                          aresetn,
    
    // AXI-Lite slave interface
    AXI4L.s                              axi_ctrl,
    
    // Table configuration outputs
    output logic                          table_write_enable,
    output logic [9:0]                    table_write_addr,
    output logic                          table_entry_valid,
    output logic [31:0]                   table_entry_prefix,
    output logic [5:0]                    table_entry_prefix_len,
    output logic [2:0]                    table_entry_action,
    output logic [47:0]                   table_entry_dst_mac,
    output logic [8:0]                    table_entry_egress_port
);

    // Register map
    localparam integer N_REGS = 16;
    localparam integer ADDR_LSB = $clog2(AXIL_DATA_BITS/8);
    localparam integer ADDR_MSB = $clog2(N_REGS);
    localparam integer AXIL_ADDR_BITS = ADDR_LSB + ADDR_MSB;

    // Internal AXI signals
    logic [AXIL_ADDR_BITS-1:0] axi_awaddr;
    logic axi_awready;
    logic [AXIL_ADDR_BITS-1:0] axi_araddr;
    logic axi_arready;
    logic [1:0] axi_bresp;
    logic axi_bvalid;
    logic axi_wready;
    logic [AXIL_DATA_BITS-1:0] axi_rdata;
    logic [1:0] axi_rresp;
    logic axi_rvalid;
    logic aw_en;

    // Register storage
    logic [N_REGS-1:0][AXIL_DATA_BITS-1:0] slv_reg;
    logic slv_reg_wren;

    /* Register Map:
     * 0x00 (RW): Control - bit[0]=table_write_trigger
     * 0x04 (RW): Table address - bits[9:0]=address
     * 0x08 (RW): Entry control - bit[0]=valid, bits[8:6]=action
     * 0x0C (RW): IPv4 prefix - bits[31:0]=prefix
     * 0x10 (RW): Prefix length - bits[5:0]=length
     * 0x14 (RW): Destination MAC low - bits[31:0]=mac[31:0]
     * 0x18 (RW): Destination MAC high - bits[15:0]=mac[47:32]
     * 0x1C (RW): Egress port - bits[8:0]=port
     */

    // Write process
    assign slv_reg_wren = axi_wready && axi_ctrl.wvalid && axi_awready && axi_ctrl.awvalid;

    // Table write pulse generation
    logic write_pulse;
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            write_pulse <= 1'b0;
            table_write_enable <= 1'b0;
        end else begin
            if (slv_reg_wren && axi_awaddr[ADDR_LSB+:ADDR_MSB] == 4'h0 && axi_ctrl.wdata[0]) begin
                write_pulse <= 1'b1;
            end else begin
                write_pulse <= 1'b0;
            end
            table_write_enable <= write_pulse;
        end
    end

    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            slv_reg <= '0;
            slv_reg[2] <= 32'h00000001; // Valid entry, action=DROP
        end else begin
            slv_reg[0][0] <= 1'b0;

            if (slv_reg_wren) begin
                case (axi_awaddr[ADDR_LSB+:ADDR_MSB])
                    4'h0, 4'h1, 4'h2, 4'h3, 4'h4, 4'h5, 4'h6, 4'h7:
                        for (int i = 0; i < AXIL_DATA_BITS/8; i++) begin
                            if (axi_ctrl.wstrb[i]) begin
                                slv_reg[axi_awaddr[ADDR_LSB+:ADDR_MSB]][(i*8)+:8] <= axi_ctrl.wdata[(i*8)+:8];
                            end
                        end
                    default: ;
                endcase
            end
        end
    end

    // Output assignments
    assign table_write_addr = slv_reg[1][9:0];
    assign table_entry_valid = slv_reg[2][0];
    assign table_entry_action = slv_reg[2][8:6];
    assign table_entry_prefix = slv_reg[3][31:0];
    assign table_entry_prefix_len = slv_reg[4][5:0];
    assign table_entry_dst_mac = {slv_reg[6][15:0], slv_reg[5][31:0]};
    assign table_entry_egress_port = slv_reg[7][8:0];

    // Read process
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_rdata <= '0;
        end else if (axi_arready & axi_ctrl.arvalid & ~axi_rvalid) begin
            case (axi_araddr[ADDR_LSB+:ADDR_MSB])
                4'h0: axi_rdata <= slv_reg[0];
                4'h1: axi_rdata <= slv_reg[1];
                4'h2: axi_rdata <= slv_reg[2];
                4'h3: axi_rdata <= slv_reg[3];
                4'h4: axi_rdata <= slv_reg[4];
                4'h5: axi_rdata <= slv_reg[5];
                4'h6: axi_rdata <= slv_reg[6];
                4'h7: axi_rdata <= slv_reg[7];
                4'h8: axi_rdata <= {31'h0, 1'b1}; // Status: always ready
                default: axi_rdata <= '0;
            endcase
        end
    end

    // Write address channel
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_awready <= 1'b0;
            axi_awaddr <= '0;
            aw_en <= 1'b1;
        end else begin
            if (~axi_awready && axi_ctrl.awvalid && axi_ctrl.wvalid && aw_en) begin
                axi_awready <= 1'b1;
                axi_awaddr <= axi_ctrl.awaddr;
                aw_en <= 1'b0;
            end else begin
                axi_awready <= 1'b0;
                if (axi_ctrl.bready && axi_bvalid)
                    aw_en <= 1'b1;
            end
        end
    end

    // Write data channel
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_wready <= 1'b0;
        end else begin
            axi_wready <= ~axi_wready && axi_ctrl.wvalid && axi_ctrl.awvalid && aw_en;
        end
    end

    // Write response channel
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_bvalid <= 1'b0;
            axi_bresp <= 2'b00;
        end else begin
            if (axi_awready && axi_ctrl.awvalid && ~axi_bvalid && axi_wready && axi_ctrl.wvalid) begin
                axi_bvalid <= 1'b1;
                axi_bresp <= 2'b00;
            end else if (axi_ctrl.bready && axi_bvalid) begin
                axi_bvalid <= 1'b0;
            end
        end
    end

    // Read address channel
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_arready <= 1'b0;
            axi_araddr <= '0;
        end else begin
            if (~axi_arready && axi_ctrl.arvalid) begin
                axi_arready <= 1'b1;
                axi_araddr <= axi_ctrl.araddr;
            end else begin
                axi_arready <= 1'b0;
            end
        end
    end

    // Read data channel
    always_ff @(posedge aclk) begin
        if (!aresetn) begin
            axi_rvalid <= 1'b0;
            axi_rresp <= 2'b00;
        end else begin
            if (axi_arready && axi_ctrl.arvalid && ~axi_rvalid) begin
                axi_rvalid <= 1'b1;
                axi_rresp <= 2'b00;
            end else if (axi_rvalid && axi_ctrl.rready) begin
                axi_rvalid <= 1'b0;
            end
        end
    end

    // Connect AXI interface
    assign axi_ctrl.awready = axi_awready;
    assign axi_ctrl.arready = axi_arready;
    assign axi_ctrl.bresp = axi_bresp;
    assign axi_ctrl.bvalid = axi_bvalid;
    assign axi_ctrl.wready = axi_wready;
    assign axi_ctrl.rdata = axi_rdata;
    assign axi_ctrl.rresp = axi_rresp;
    assign axi_ctrl.rvalid = axi_rvalid;

endmodule