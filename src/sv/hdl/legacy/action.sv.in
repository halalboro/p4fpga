// =============================================================================
// Action Execution Module
//
// Executes P4 actions on packet headers based on match results.
// Supports field modifications, MAC swaps, TTL decrements, ECN marking,
// stateful operations, and stack operations.
//
// Generated by P4-FPGA Compiler
// =============================================================================

module action #(
    // ==========================================
    // Configuration Parameters
    // ==========================================
    parameter DATA_WIDTH = 512,
    parameter ACTION_DATA_WIDTH = 128,
    parameter METADATA_WIDTH = 64,

    // Action configuration bitmask
    // [0] = FORWARD
    // [1] = DROP
    // [2] = MODIFY_HEADER
    // [3] = ENCAP
    // [4] = DECAP
    // [5] = HASH
    // [6] = SET_FIELD
    // [7] = MULTICAST
    parameter [7:0] ACTION_CONFIG = 8'b00000111,  // Forward, Drop, Modify
    
    // Egress processing configuration
    // [0] = ENABLE_EGRESS
    // [1] = ENABLE_ECN_MARKING
    // [2] = ENABLE_STATEFUL (registers/counters)
    // [3] = ENABLE_MIRRORING
    // [4] = ENABLE_EGRESS_TABLE
    // [5] = ENABLE_PUSH_FRONT
    // [6] = ENABLE_MULTICAST
    parameter [7:0] EGRESS_CONFIG = {{EGRESS_CONFIG}},  // Generated by compiler
    
    // Stateful configuration
    parameter NUM_REGISTERS = 1024,               // Number of stateful registers
    parameter REGISTER_WIDTH = 32,                // Width of each register
    
    // Egress register configuration
    parameter NUM_EGRESS_REGISTERS = {{NUM_EGRESS_REGISTERS}},
    parameter EGRESS_REG_WIDTH = 32,              // Width of egress registers
    parameter TIME_WIDTH = 48,                    // Timestamp width
    
    // ECN threshold (queue depth)
    parameter [18:0] ECN_THRESHOLD = {{ECN_THRESHOLD}},
    
    // Egress table configuration
    parameter EGRESS_TABLE_SIZE = 16,
    parameter EGRESS_ACTION_DATA_WIDTH = 64
) (
    input  wire                           aclk,
    input  wire                           aresetn,

{{STACK_POINTER_INPUTS}}
{{STACK_POINTER_OUTPUTS}}

    // ==========================================
    // Custom Header Data Inputs (for stack access)
    // ==========================================
{{ACTION_CUSTOM_HEADER_INPUTS}}

    // ==========================================
    // Packet Input
    // ==========================================
    input  wire [DATA_WIDTH-1:0]          packet_in,
    input  wire [DATA_WIDTH/8-1:0]        packet_keep_in,
    input  wire                           packet_last_in,
    input  wire                           packet_valid,
    output reg                            packet_ready,
    
    // ==========================================
    // Metadata Input/Output
    // ==========================================
    input  wire [METADATA_WIDTH-1:0]      metadata_in,
    output reg  [METADATA_WIDTH-1:0]      metadata_out,

    // ==========================================
    // Action Control (Ingress)
    // ==========================================
    input  wire [3:0]                     action_id,
    input  wire [ACTION_DATA_WIDTH-1:0]   action_data,
    input  wire                           action_valid,
    
    // ==========================================
    // Ingress Header Fields (from match engine)
    // ==========================================
    input  wire                           ipv4_valid,
    input  wire [47:0]                    eth_dst_addr,
    input  wire [47:0]                    eth_src_addr,
    input  wire [7:0]                     ipv4_ttl,
    input  wire [31:0]                    ipv4_src_addr,
    input  wire [31:0]                    ipv4_dst_addr,
    input  wire [15:0]                    ipv4_src_port,
    input  wire [15:0]                    ipv4_dst_port,
    input  wire [7:0]                     ipv4_protocol,
    input  wire [5:0]                     ipv4_diffserv_in,
    input  wire [1:0]                     ipv4_ecn_in,
    
    // ==========================================
    // Hash Input (for stateful indexing)
    // ==========================================
    input  wire [31:0]                    flow_hash,
    
    // ==========================================
    // Egress Control Inputs
    // ==========================================
    input  wire [18:0]                    enq_qdepth,
    
    // Standard Metadata for Egress
    input  wire [8:0]                     egress_port_id,
    input  wire [8:0]                     ingress_port_in,
    input  wire [15:0]                    packet_length_in,
    
    // Probe header valid (for link_monitor)
    input  wire                           probe_valid,
    input  wire [7:0]                     probe_hop_cnt,

    // MRI header valid (for INT/MRI)
    input  wire                           mri_valid,
    input  wire [15:0]                    mri_count_in,
    input  wire [18:0]                    deq_qdepth,
    input  wire [3:0]                     ipv4_ihl_in,
    input  wire [7:0]                     ipv4_option_length_in,
    input  wire [15:0]                    ipv4_total_len_in,
    
    // ==========================================
    // Packet Output
    // ==========================================
    output reg  [DATA_WIDTH-1:0]          packet_out,
    output reg  [DATA_WIDTH/8-1:0]        packet_keep_out,
    output reg                            packet_last_out,
    output reg                            packet_out_valid,
    input  wire                           packet_out_ready,
    
    // ==========================================
    // Action Results
    // ==========================================
    output reg                            drop,
    output reg  [8:0]                     egress_port,
    output reg  [15:0]                    mcast_grp,
    output reg                            header_modified,
    output reg                            ecn_marked,
    output reg  [5:0]                     ipv4_diffserv_out,
    output reg  [1:0]                     ipv4_ecn_out,
    output reg  [7:0]                     ipv4_ttl_out,

    // ==========================================
    // Custom Header Outputs
    // ==========================================
{{ACTION_CUSTOM_HEADER_OUTPUTS}}

    // MRI outputs (for INT/MRI)
    output reg  [15:0]                    mri_count_out,
    output reg  [3:0]                     ipv4_ihl_out,
    output reg  [7:0]                     ipv4_option_length_out,
    output reg  [15:0]                    ipv4_total_len_out,
    // swtraces[0] outputs (filled during add_swtrace action)
    output reg  [31:0]                    swtraces_0_swid_out,
    output reg  [31:0]                    swtraces_0_qdepth_out,
    output reg                            swtraces_0_valid_out,

    // Egress table programming
    input  wire                           egress_table_write_enable,
    input  wire [$clog2(EGRESS_TABLE_SIZE)-1:0] egress_table_write_addr,
    input  wire [2:0]                     egress_table_entry_action,
    input  wire [EGRESS_ACTION_DATA_WIDTH-1:0] egress_table_entry_data
);

    // ==========================================
    // Action ID Definitions (Ingress)
    // ==========================================
    localparam ACTION_FORWARD       = 4'd0;
    localparam ACTION_DROP          = 4'd1;
    localparam ACTION_NOACTION      = 4'd2;
    localparam ACTION_ENCAP         = 4'd3;
    localparam ACTION_DECAP         = 4'd4;
    localparam ACTION_HASH_SELECT   = 4'd5;
    localparam ACTION_CHECK_STATE   = 4'd6;
    localparam ACTION_UPDATE_STATE  = 4'd7;
    localparam ACTION_SET_FIELD     = 4'd8;
    localparam ACTION_HASH_COMPUTE  = 4'd9;
    localparam ACTION_MULTICAST     = 4'd10;
    
    // Egress Action IDs
    localparam EGRESS_ACTION_NOACTION    = 3'd0;
    localparam EGRESS_ACTION_SET_SWID    = 3'd1;
    localparam EGRESS_ACTION_ADD_SWTRACE = 3'd2;  // MRI/INT add_swtrace
    
    // ==========================================
    // Configuration Bits
    // ==========================================
    localparam ENABLE_FORWARD       = ACTION_CONFIG[0];
    localparam ENABLE_DROP          = ACTION_CONFIG[1];
    localparam ENABLE_MODIFY_HEADER = ACTION_CONFIG[2];
    localparam ENABLE_ENCAP         = ACTION_CONFIG[3];
    localparam ENABLE_DECAP         = ACTION_CONFIG[4];
    localparam ENABLE_HASH          = ACTION_CONFIG[5];
    localparam ENABLE_SET_FIELD     = ACTION_CONFIG[6];
    localparam ENABLE_MULTICAST     = ACTION_CONFIG[7];
    
    // Egress configuration bits
    localparam ENABLE_EGRESS        = EGRESS_CONFIG[0];
    localparam ENABLE_ECN_MARKING   = EGRESS_CONFIG[1];
    localparam ENABLE_STATEFUL      = EGRESS_CONFIG[2];
    localparam ENABLE_MIRRORING     = EGRESS_CONFIG[3];
    localparam ENABLE_EGRESS_TABLE  = EGRESS_CONFIG[4];
    localparam ENABLE_PUSH_FRONT    = EGRESS_CONFIG[5];
    localparam ENABLE_MCAST_PRUNING = EGRESS_CONFIG[6];

    // ==========================================
    // Internal Timestamp Counter
    // ==========================================
    reg [TIME_WIDTH-1:0] global_timestamp;
    
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn)
            global_timestamp <= {TIME_WIDTH{1'b0}};
        else
            global_timestamp <= global_timestamp + 1;
    end

    // ==========================================
    // Internal Signals
    // ==========================================
    reg [DATA_WIDTH-1:0]     ingress_packet;
    reg [DATA_WIDTH-1:0]     egress_packet;
    reg [1:0]                ecn_bits;
    reg [METADATA_WIDTH-1:0] metadata_reg;
    
    // ==========================================
    // Ingress Stateful Register Interface Signals
    // ==========================================
    reg  [$clog2(NUM_REGISTERS)-1:0] stateful_reg_addr_in;
    reg  [REGISTER_WIDTH-1:0]        stateful_reg_write_data_in;
    reg                              stateful_reg_write_en_in;
    wire [REGISTER_WIDTH-1:0]        stateful_reg_read_data_out;
    
    // ==========================================
    // Egress Register Interface Signals
    // ==========================================
    reg  [$clog2(NUM_EGRESS_REGISTERS)-1:0] egress_reg_index_in;
    reg  [EGRESS_REG_WIDTH-1:0]             byte_cnt_write_data_in;
    reg                                     byte_cnt_write_en_in;
    reg  [TIME_WIDTH-1:0]                   last_time_write_data_in;
    reg                                     last_time_write_en_in;
    wire [EGRESS_REG_WIDTH-1:0]             byte_cnt_read_out;
    wire [TIME_WIDTH-1:0]                   last_time_read_out;
    
    // ==========================================
    // Egress Table Interface Signals
    // ==========================================
    wire [2:0]                              egress_action_id_out;
    wire [EGRESS_ACTION_DATA_WIDTH-1:0]     egress_action_data_out;

    // ==========================================
    // Ingress Stateful Register Array
    // ==========================================
    generate
        if (ENABLE_STATEFUL) begin : gen_stateful
            reg [REGISTER_WIDTH-1:0] state_registers [0:NUM_REGISTERS-1];
            
            initial begin
                for (int i = 0; i < NUM_REGISTERS; i++) begin
                    state_registers[i] = {REGISTER_WIDTH{1'b0}};
                end
            end
            
            // Combinational read
            assign stateful_reg_read_data_out = state_registers[stateful_reg_addr_in];
            
            // Sequential write
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    for (int i = 0; i < NUM_REGISTERS; i++) begin
                        state_registers[i] <= {REGISTER_WIDTH{1'b0}};
                    end
                end else if (stateful_reg_write_en_in) begin
                    state_registers[stateful_reg_addr_in] <= stateful_reg_write_data_in;
                end
            end
        end else begin : gen_no_stateful
            assign stateful_reg_read_data_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Egress Register Arrays
    // For link_monitor: byte_cnt_reg and last_time_reg
    // ==========================================
    generate
        if (ENABLE_EGRESS && ENABLE_STATEFUL) begin : gen_egress_registers
            reg [EGRESS_REG_WIDTH-1:0] byte_cnt_reg [0:NUM_EGRESS_REGISTERS-1];
            reg [TIME_WIDTH-1:0]       last_time_reg [0:NUM_EGRESS_REGISTERS-1];
            
            initial begin
                for (int j = 0; j < NUM_EGRESS_REGISTERS; j++) begin
                    byte_cnt_reg[j]  = {EGRESS_REG_WIDTH{1'b0}};
                    last_time_reg[j] = {TIME_WIDTH{1'b0}};
                end
            end
            
            // Combinational read
            assign byte_cnt_read_out  = byte_cnt_reg[egress_reg_index_in];
            assign last_time_read_out = last_time_reg[egress_reg_index_in];
            
            // Sequential write
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    for (int j = 0; j < NUM_EGRESS_REGISTERS; j++) begin
                        byte_cnt_reg[j]  <= {EGRESS_REG_WIDTH{1'b0}};
                        last_time_reg[j] <= {TIME_WIDTH{1'b0}};
                    end
                end else begin
                    if (byte_cnt_write_en_in)
                        byte_cnt_reg[egress_reg_index_in] <= byte_cnt_write_data_in;
                    if (last_time_write_en_in)
                        last_time_reg[egress_reg_index_in] <= last_time_write_data_in;
                end
            end
        end else begin : gen_no_egress_registers
            assign byte_cnt_read_out  = '0;
            assign last_time_read_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Egress Table (swid table)
    // ==========================================
    generate
        if (ENABLE_EGRESS && ENABLE_EGRESS_TABLE) begin : gen_egress_table
            typedef struct packed {
                logic                              valid;
                logic [2:0]                        action_id;
                logic [EGRESS_ACTION_DATA_WIDTH-1:0] action_data;
            } egress_table_entry_t;
            
            egress_table_entry_t egress_table [0:EGRESS_TABLE_SIZE-1];
            
            // Table lookup result (internal)
            reg [2:0]                        egress_action_id;
            reg [EGRESS_ACTION_DATA_WIDTH-1:0] egress_action_data;
            reg                              egress_table_hit;
            
            initial begin
                for (int k = 0; k < EGRESS_TABLE_SIZE; k++) begin
                    egress_table[k].valid = 1'b0;
                    egress_table[k].action_id = 3'd0;
                    egress_table[k].action_data = '0;
                end
            end
            
            // Table write
            always_ff @(posedge aclk) begin
                if (egress_table_write_enable) begin
                    egress_table[egress_table_write_addr].valid      <= 1'b1;
                    egress_table[egress_table_write_addr].action_id  <= egress_table_entry_action;
                    egress_table[egress_table_write_addr].action_data <= egress_table_entry_data;
                end
            end
            
            // Table lookup (default entry at index 0)
            always_comb begin
                if (egress_table[0].valid) begin
                    egress_table_hit   = 1'b1;
                    egress_action_id   = egress_table[0].action_id;
                    egress_action_data = egress_table[0].action_data;
                end else begin
                    egress_table_hit   = 1'b0;
                    egress_action_id   = EGRESS_ACTION_NOACTION;
                    egress_action_data = '0;
                end
            end
            
            // Interface signals
            assign egress_action_id_out   = egress_action_id;
            assign egress_action_data_out = egress_action_data;
        end else begin : gen_no_egress_table
            assign egress_action_id_out   = EGRESS_ACTION_NOACTION;
            assign egress_action_data_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Backpressure
    // ==========================================
    always_comb begin
        packet_ready = packet_out_ready;
    end
    
    // ==========================================
    // Action Execution (Unified Pipeline)
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            packet_out        <= '0;
            packet_keep_out   <= '0;
            packet_last_out   <= 1'b0;
            packet_out_valid  <= 1'b0;
            drop              <= 1'b0;
            egress_port       <= 9'd0;
            mcast_grp         <= 16'd0;
            header_modified   <= 1'b0;
            ecn_marked        <= 1'b0;
            ipv4_diffserv_out <= 6'b0;
            ipv4_ecn_out      <= 2'b0;
            ipv4_ttl_out      <= 8'b0;
            metadata_out      <= '0;

            // MRI outputs reset
            mri_count_out          <= 16'd0;
            ipv4_ihl_out           <= 4'd0;
            ipv4_option_length_out <= 8'd0;
            ipv4_total_len_out     <= 16'd0;
            swtraces_0_swid_out    <= 32'd0;
            swtraces_0_qdepth_out  <= 32'd0;
            swtraces_0_valid_out   <= 1'b0;

{{RESET_CUSTOM_HEADER_OUTPUTS}}

            // Reset interface signals
            stateful_reg_addr_in       <= '0;
            stateful_reg_write_data_in <= '0;
            stateful_reg_write_en_in   <= 1'b0;
            egress_reg_index_in        <= '0;
            byte_cnt_write_data_in     <= '0;
            byte_cnt_write_en_in       <= 1'b0;
            last_time_write_data_in    <= '0;
            last_time_write_en_in      <= 1'b0;

{{STACK_POINTER_RESET_OUT}}

        end else if (packet_ready) begin
            packet_out_valid  <= packet_valid && action_valid;
            packet_keep_out   <= packet_keep_in;
            packet_last_out   <= packet_last_in;
            
            // Default: pass through header fields
            metadata_reg      <= metadata_in;
            
            // Default: no writes
            stateful_reg_write_en_in <= 1'b0;
            byte_cnt_write_en_in     <= 1'b0;
            last_time_write_en_in    <= 1'b0;

{{DEFAULT_CUSTOM_HEADER_OUTPUTS}}

            if (packet_valid && action_valid) begin
                // ============================================
                // STAGE 1: INGRESS PROCESSING
                // ============================================
                ipv4_diffserv_out <= ipv4_diffserv_in;
                ipv4_ecn_out      <= ipv4_ecn_in;
                ipv4_ttl_out      <= ipv4_ttl;
                ingress_packet    <= packet_in;
                drop              <= 1'b0;
                egress_port       <= 9'd0;
                mcast_grp         <= 16'd0;
                header_modified   <= 1'b0;
                
                case (action_id)
{{STACK_POINTER_LOGIC_INOUT}}

                    // ==========================================
                    // FORWARD Action (L2/L3 forwarding)
                    // ==========================================
                    ACTION_FORWARD: begin
                        if (ENABLE_FORWARD) begin
                            // L2 forwarding: set egress port from action_data
                            egress_port     <= {1'b0, action_data[103:96]};
                            header_modified <= 1'b0;
                            drop            <= 1'b0;

                            // L3 forwarding with TTL decrement (only for IPv4)
                            if (ENABLE_MODIFY_HEADER && ipv4_valid) begin
                                ingress_packet[47:0] <= action_data[47:0];
                                ingress_packet[95:48] <= eth_dst_addr;

                                // Drop if TTL is 0 or 1 (would become 0 after decrement)
                                if (ipv4_ttl > 8'd1) begin
                                    ingress_packet[183:176] <= ipv4_ttl - 8'd1;
                                    ipv4_ttl_out    <= ipv4_ttl - 8'd1;
                                    header_modified <= 1'b1;
                                end else begin
                                    drop <= 1'b1;
                                end
                            end
                        end
                    end
                    
                    // ==========================================
                    // DROP Action
                    // ==========================================
                    ACTION_DROP: begin
                        if (ENABLE_DROP) begin
                            drop <= 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // NOACTION
                    // ==========================================
                    ACTION_NOACTION: begin
                        drop            <= 1'b0;
                        header_modified <= 1'b0;
                    end
                    
                    // ==========================================
                    // MULTICAST Action
                    // ==========================================
                    ACTION_MULTICAST: begin
                        if (ENABLE_MULTICAST) begin
                            mcast_grp       <= action_data[15:0];
                            drop            <= 1'b0;
                            header_modified <= 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // CHECK_STATE Action (for firewall)
                    // ==========================================
                    ACTION_CHECK_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            stateful_reg_addr_in <= flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            if (stateful_reg_read_data_out == 32'd0) begin
                                drop <= 1'b1;
                            end else begin
                                drop <= 1'b0;
                            end
                        end
                    end
                    
                    // ==========================================
                    // UPDATE_STATE Action (for firewall)
                    // ==========================================
                    ACTION_UPDATE_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            stateful_reg_addr_in       <= flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            stateful_reg_write_data_in <= 32'd1;
                            stateful_reg_write_en_in   <= 1'b1;
                            drop            <= 1'b0;
                            header_modified <= 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // ENCAP Action (for tunneling)
                    // ==========================================
                    ACTION_ENCAP: begin
                        if (ENABLE_ENCAP) begin
                            // Shift packet and prepend tunnel header
                            // Implementation depends on tunnel type
                            header_modified <= 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // DECAP Action (for tunneling)
                    // ==========================================
                    ACTION_DECAP: begin
                        if (ENABLE_DECAP) begin
                            // Remove outer header
                            // Implementation depends on tunnel type
                            header_modified <= 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // HASH_COMPUTE Action (for load balancing)
                    // ==========================================
                    ACTION_HASH_COMPUTE: begin
                        if (ENABLE_HASH) begin
                            // Write hash to metadata[31:0] (first 32 bits)
                            metadata_reg[31:0] <= flow_hash;
                            
                            // Use hash to select egress port
                            egress_port <= flow_hash[8:0];  // Bottom 9 bits
                            
                            drop <= 1'b0;
                            header_modified <= 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // SET_FIELD Action (for QoS)
                    // ==========================================
                    ACTION_SET_FIELD: begin
                        if (ENABLE_SET_FIELD) begin
                            // action_data layout for SET_FIELD:
                            // [7:0]   = field_id (which field to modify)
                            // [15:8]  = field_value (value to set)
                            
                            automatic logic [7:0] field_id;
                            automatic logic [7:0] field_value;
                            
                            field_id = action_data[7:0];
                            field_value = action_data[15:8];
                            
                            case (field_id)
                                8'd0: begin  // FIELD_DIFFSERV
                                    ipv4_diffserv_out <= field_value[5:0];
                                    header_modified <= 1'b1;
                                end
                                8'd1: begin  // FIELD_ECN
                                    ipv4_ecn_out <= field_value[1:0];
                                    header_modified <= 1'b1;
                                end
                                8'd2: begin  // FIELD_TTL
                                    ipv4_ttl_out <= field_value;
                                    header_modified <= 1'b1;
                                end
                                default: begin
                                    // Unknown field, pass through
                                    header_modified <= 1'b0;
                                end
                            endcase
                            
                            drop <= 1'b0;
                            egress_port <= 9'd0;  // No egress port change
                        end
                    end

                    default: begin
                        // Default: pass through (NOACTION)
                        // This allows byte counting without table programming
                        drop            <= 1'b0;
                        header_modified <= 1'b0;
                    end
                endcase
                
                // ============================================
                // STAGE 2: EGRESS PROCESSING 
                // ============================================
                
                egress_packet <= ingress_packet;
                ecn_marked    <= 1'b0;
                
                if (ENABLE_EGRESS && !drop) begin
                    
                    // ------------------------------------------
                    // MULTICAST PRUNING (ingress_port == egress_port)
                    // ------------------------------------------
                    if (ENABLE_MCAST_PRUNING && (mcast_grp != 16'd0)) begin
                        if (egress_port_id == ingress_port_in) begin
                            drop <= 1'b1;
                        end
                    end
                    
                    // ------------------------------------------
                    // ECN MARKING LOGIC
                    // ------------------------------------------
                    if (ENABLE_ECN_MARKING && ipv4_valid) begin
                        ecn_bits <= ipv4_ecn_in;
                        if (ecn_bits == 2'b01 || ecn_bits == 2'b10) begin
                            if (enq_qdepth >= ECN_THRESHOLD) begin
                                ipv4_ecn_out    <= 2'b11;
                                header_modified <= 1'b1;
                                ecn_marked      <= 1'b1;
                            end
                        end
                    end
                    
                    // ------------------------------------------
                    // EGRESS REGISTER OPERATIONS
                    // (link_monitor.p4 byte counting logic)
                    // ------------------------------------------
                    if (ENABLE_STATEFUL) begin
                        egress_reg_index_in <= egress_port_id[$clog2(NUM_EGRESS_REGISTERS)-1:0];
                        
                        begin
                            reg [EGRESS_REG_WIDTH-1:0] current_byte_cnt;
                            reg [EGRESS_REG_WIDTH-1:0] new_byte_cnt;
                            
                            current_byte_cnt = byte_cnt_read_out;
                            new_byte_cnt = current_byte_cnt + {16'd0, packet_length_in};

{{EGRESS_CUSTOM_HEADER_LOGIC}}
                        end
                    end

                    // ------------------------------------------
                    // MRI/INT EGRESS PROCESSING
                    // (add_swtrace action for In-band Network Telemetry)
                    // ------------------------------------------
                    if (ENABLE_EGRESS_TABLE && ENABLE_PUSH_FRONT && mri_valid) begin
                        if (egress_action_id_out == EGRESS_ACTION_ADD_SWTRACE) begin
                            // MRI add_swtrace action:
                            // 1. Increment mri.count
                            // 2. push_front on swtraces (handled by stack pointer)
                            // 3. Set swtraces[0].swid = egress_action_data (table parameter)
                            // 4. Set swtraces[0].qdepth = deq_qdepth
                            // 5. Increment ipv4.ihl by 2 (64 bits = 8 bytes = 2 x 32-bit words)
                            // 6. Increment ipv4_option.optionLength by 8
                            // 7. Increment ipv4.totalLen by 8

                            mri_count_out          <= mri_count_in + 16'd1;
                            ipv4_ihl_out           <= ipv4_ihl_in + 4'd2;
                            ipv4_option_length_out <= ipv4_option_length_in + 8'd8;
                            ipv4_total_len_out     <= ipv4_total_len_in + 16'd8;

                            // Set swtraces[0] - the newly pushed element
                            // swid comes from egress table action_data (table parameter)
                            // qdepth comes from standard_metadata.deq_qdepth
                            swtraces_0_swid_out   <= egress_action_data_out[31:0];
                            swtraces_0_qdepth_out <= {13'd0, deq_qdepth};
                            swtraces_0_valid_out  <= 1'b1;  // setValid()

                            header_modified <= 1'b1;
                        end else begin
                            // Pass through MRI values unchanged
                            mri_count_out          <= mri_count_in;
                            ipv4_ihl_out           <= ipv4_ihl_in;
                            ipv4_option_length_out <= ipv4_option_length_in;
                            ipv4_total_len_out     <= ipv4_total_len_in;
                            swtraces_0_valid_out   <= 1'b0;
                        end
                    end else if (mri_valid) begin
                        // MRI valid but no egress table action - pass through
                        mri_count_out          <= mri_count_in;
                        ipv4_ihl_out           <= ipv4_ihl_in;
                        ipv4_option_length_out <= ipv4_option_length_in;
                        ipv4_total_len_out     <= ipv4_total_len_in;
                        swtraces_0_valid_out   <= 1'b0;
                    end

                    // ------------------------------------------
                    // MIRRORING LOGIC (placeholder)
                    // ------------------------------------------
                    if (ENABLE_MIRRORING) begin
                        // Future: Clone packet to mirror port
                    end
                end
                
                // Output final packet
                packet_out   <= egress_packet;
                metadata_out <= metadata_reg;
            end
        end
    end

endmodule

// ============================================================================
// hash module
// Supports CRC16, CRC32, and XOR hashing 
// ============================================================================

module hash #(
    parameter HASH_TYPE = 0,     // 0=CRC16, 1=CRC32, 2=XOR
    parameter INPUT_WIDTH = 104, // 5-tuple = 104 bits (default)
    parameter OUTPUT_WIDTH = 16  // Output hash width
) (
    input  wire                        aclk,
    input  wire                        aresetn,
    
    // Input data interface
    input  wire [INPUT_WIDTH-1:0]      data_in,
    input  wire                        valid_in,
    output wire                        ready_out,
    
    // Output hash interface
    output reg  [OUTPUT_WIDTH-1:0]     hash_out,
    output reg                         valid_out
);

    // ==========================================
    // CRC Polynomials
    // ==========================================
    localparam [15:0] CRC16_POLY = 16'h1021;
    localparam [31:0] CRC32_POLY = 32'h04C11DB7;
    
    // ==========================================
    // Always ready (single-cycle operation)
    // ==========================================
    assign ready_out = 1'b1;

    // ==========================================
    // Hash Type Generation
    // ==========================================
    generate
        // ==========================================
        // CRC16 Hash
        // ==========================================
        if (HASH_TYPE == 0) begin : gen_crc16
            
            // Process 8 bits through CRC16
            function automatic [15:0] crc16_byte;
                input [15:0] crc_in;
                input [7:0] data_byte;
                reg [15:0] crc;
                integer i;
                begin
                    crc = crc_in ^ {data_byte, 8'h00};
                    for (i = 0; i < 8; i = i + 1) begin
                        if (crc[15])
                            crc = {crc[14:0], 1'b0} ^ CRC16_POLY;
                        else
                            crc = {crc[14:0], 1'b0};
                    end
                    crc16_byte = crc;
                end
            endfunction
            
            // Combinational CRC calculation with explicit byte extraction
            wire [15:0] crc_result;
            wire [127:0] padded_data = {{(128-INPUT_WIDTH){1'b0}}, data_in};
            
            wire [15:0] crc_b0  = crc16_byte(16'hFFFF,      padded_data[7:0]);
            wire [15:0] crc_b1  = crc16_byte(crc_b0,        padded_data[15:8]);
            wire [15:0] crc_b2  = crc16_byte(crc_b1,        padded_data[23:16]);
            wire [15:0] crc_b3  = crc16_byte(crc_b2,        padded_data[31:24]);
            wire [15:0] crc_b4  = crc16_byte(crc_b3,        padded_data[39:32]);
            wire [15:0] crc_b5  = crc16_byte(crc_b4,        padded_data[47:40]);
            wire [15:0] crc_b6  = crc16_byte(crc_b5,        padded_data[55:48]);
            wire [15:0] crc_b7  = crc16_byte(crc_b6,        padded_data[63:56]);
            wire [15:0] crc_b8  = crc16_byte(crc_b7,        padded_data[71:64]);
            wire [15:0] crc_b9  = crc16_byte(crc_b8,        padded_data[79:72]);
            wire [15:0] crc_b10 = crc16_byte(crc_b9,        padded_data[87:80]);
            wire [15:0] crc_b11 = crc16_byte(crc_b10,       padded_data[95:88]);
            wire [15:0] crc_b12 = crc16_byte(crc_b11,       padded_data[103:96]);
            
            assign crc_result = ~crc_b12;
            
            always_ff @(posedge aclk or negedge aresetn) begin
                if (!aresetn) begin
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    hash_out  <= crc_result[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
        // ==========================================
        // CRC32 Hash
        // ==========================================
        end else if (HASH_TYPE == 1) begin : gen_crc32
            
            // Process 8 bits through CRC32 (reflected)
            function automatic [31:0] crc32_byte;
                input [31:0] crc_in;
                input [7:0] data_byte;
                reg [31:0] crc;
                integer i;
                begin
                    crc = crc_in ^ {24'h000000, data_byte};
                    for (i = 0; i < 8; i = i + 1) begin
                        if (crc[0])
                            crc = {1'b0, crc[31:1]} ^ CRC32_POLY;
                        else
                            crc = {1'b0, crc[31:1]};
                    end
                    crc32_byte = crc;
                end
            endfunction
            
            // Combinational CRC calculation with explicit byte extraction
            wire [31:0] crc_result;
            wire [127:0] padded_data = {{(128-INPUT_WIDTH){1'b0}}, data_in};
            
            wire [31:0] crc_b0  = crc32_byte(32'hFFFFFFFF, padded_data[7:0]);
            wire [31:0] crc_b1  = crc32_byte(crc_b0,       padded_data[15:8]);
            wire [31:0] crc_b2  = crc32_byte(crc_b1,       padded_data[23:16]);
            wire [31:0] crc_b3  = crc32_byte(crc_b2,       padded_data[31:24]);
            wire [31:0] crc_b4  = crc32_byte(crc_b3,       padded_data[39:32]);
            wire [31:0] crc_b5  = crc32_byte(crc_b4,       padded_data[47:40]);
            wire [31:0] crc_b6  = crc32_byte(crc_b5,       padded_data[55:48]);
            wire [31:0] crc_b7  = crc32_byte(crc_b6,       padded_data[63:56]);
            wire [31:0] crc_b8  = crc32_byte(crc_b7,       padded_data[71:64]);
            wire [31:0] crc_b9  = crc32_byte(crc_b8,       padded_data[79:72]);
            wire [31:0] crc_b10 = crc32_byte(crc_b9,       padded_data[87:80]);
            wire [31:0] crc_b11 = crc32_byte(crc_b10,      padded_data[95:88]);
            wire [31:0] crc_b12 = crc32_byte(crc_b11,      padded_data[103:96]);
            
            assign crc_result = ~crc_b12;
            
            always_ff @(posedge aclk or negedge aresetn) begin
                if (!aresetn) begin
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    hash_out  <= crc_result[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
        // ==========================================
        // XOR Hash (Simplest, Fastest)
        // ==========================================
        end else begin : gen_xor
            
            // XOR fold all 32-bit words
            wire [127:0] padded_data = {{(128-INPUT_WIDTH){1'b0}}, data_in};
            wire [31:0] xor_result = padded_data[31:0] ^ padded_data[63:32] ^ 
                                     padded_data[95:64] ^ padded_data[127:96];
            
            always_ff @(posedge aclk or negedge aresetn) begin
                if (!aresetn) begin
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    hash_out  <= xor_result[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
        end
    endgenerate

endmodule