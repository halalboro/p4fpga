// =============================================================================
// Match (Lookup Table) Module
//
// Implements table lookup operations for P4 match-action tables.
// Supports multiple match types: Exact, LPM, Ternary, and Range.
// Returns matched action ID and action data for execution.
//
// Generated by P4-FPGA Compiler
// =============================================================================

module match #(
    // ==========================================
    // Configuration Parameters
    // ==========================================
    parameter MATCH_TYPE = 1,        // 0=Exact, 1=LPM, 2=Ternary, 3=Range
    parameter KEY_WIDTH = 32,
    parameter TABLE_SIZE = 1024,
    parameter ACTION_DATA_WIDTH = 128,
    parameter DATA_WIDTH = 512
) (
    input  wire                           aclk,
    input  wire                           aresetn,
    
    // ==========================================
    // Lookup Interface
    // ==========================================
    input  wire [KEY_WIDTH-1:0]           lookup_key,
    input  wire [KEY_WIDTH-1:0]           lookup_key_mask,    // For ternary
    input  wire                           lookup_valid,
    output reg                            lookup_ready,
    
    // ==========================================
    // Header validity preservation
    // ==========================================
    input  wire                           ipv4_valid_in,

    // ==========================================
    // Custom header inputs (for pass-through)
    // ==========================================
{{MATCH_CUSTOM_HEADER_INPUTS}}

    // ==========================================
    // Header fields pass-through
    // ==========================================
    input  wire [47:0]                    eth_dst_addr_in,
    input  wire [47:0]                    eth_src_addr_in,
    input  wire [7:0]                     ipv4_ttl_in,
    input  wire [5:0]                     ipv4_diffserv_in,
    input  wire [1:0]                     ipv4_ecn_in,
    
    // ==========================================
    // Packet data pass-through
    // ==========================================
    input  wire [DATA_WIDTH-1:0]          packet_data_in,
    input  wire [DATA_WIDTH/8-1:0]        packet_keep_in,
    input  wire                           packet_last_in,
    
    // ==========================================
    // Match Results
    // ==========================================
    output reg                            match_hit,
    output reg  [3:0]                     match_action_id,
    output reg  [ACTION_DATA_WIDTH-1:0]   match_action_data,
    output reg                            match_valid,
    
    // ==========================================
    // Preserved outputs
    // ==========================================
    output reg                            ipv4_valid_out,
    output reg  [47:0]                    eth_dst_addr_out,
    output reg  [47:0]                    eth_src_addr_out,
    output reg  [7:0]                     ipv4_ttl_out,
    output reg  [5:0]                     ipv4_diffserv_out,
    output reg  [1:0]                     ipv4_ecn_out,
    output reg  [DATA_WIDTH-1:0]          packet_data_out,
    output reg  [DATA_WIDTH/8-1:0]        packet_keep_out,
    output reg                            packet_last_out,

    // ==========================================
    // Custom header outputs (pass-through)
    // ==========================================
{{MATCH_CUSTOM_HEADER_OUTPUTS}}

    // ==========================================
    // Table Programming Interface
    // ==========================================
    input  wire                           table_write_enable,
    input  wire [$clog2(TABLE_SIZE)-1:0]  table_write_addr,
    input  wire                           table_entry_valid,
    input  wire [KEY_WIDTH-1:0]           table_entry_key,
    input  wire [KEY_WIDTH-1:0]           table_entry_mask,     // For LPM/Ternary
    input  wire [5:0]                     table_entry_prefix_len, // For LPM
    input  wire [2:0]                     table_entry_action_id,
    input  wire [ACTION_DATA_WIDTH-1:0]   table_entry_action_data
);

    // ==========================================
    // Table Entry Structure
    // ==========================================
    typedef struct packed {
        logic                           valid;
        logic [KEY_WIDTH-1:0]          key;
        logic [KEY_WIDTH-1:0]          mask;           // For Ternary/LPM
        logic [5:0]                    prefix_len;     // For LPM
        logic [2:0]                    action_id;
        logic [ACTION_DATA_WIDTH-1:0]  action_data;
    } table_entry_t;
    
    // ==========================================
    // Table Storage
    // ==========================================
    table_entry_t table_mem [0:TABLE_SIZE-1];
    
    // ==========================================
    // Pipeline registers for pass-through
    // ==========================================
    reg                           ipv4_valid_d1;
    reg  [47:0]                   eth_dst_d1;
    reg  [47:0]                   eth_src_d1;
    reg  [7:0]                    ipv4_ttl_d1;
    reg  [5:0]                    ipv4_diffserv_d1;
    reg  [1:0]                    ipv4_ecn_d1;
    reg  [DATA_WIDTH-1:0]         packet_data_d1;
    reg  [DATA_WIDTH/8-1:0]       packet_keep_d1;
    reg                           packet_last_d1;
    reg                           lookup_valid_d1;
    reg  [KEY_WIDTH-1:0]          lookup_key_d1;

    // Custom header pipeline registers
{{MATCH_CUSTOM_HEADER_REGS}}

    // ==========================================
    // Internal Signals
    // ==========================================
    reg  [KEY_WIDTH-1:0] match_mask;
    reg                  entry_matches;
    
    // ==========================================
    // Table Initialization
    // ==========================================
    initial begin
        for (int i = 0; i < TABLE_SIZE; i++) begin
            table_mem[i].valid = 1'b0;
            table_mem[i].action_id = 3'd1;  // Default: drop
        end
    end
    
    // ==========================================
    // Table Write Logic
    // ==========================================
    always_ff @(posedge aclk) begin
        if (table_write_enable) begin
            table_mem[table_write_addr].valid       <= table_entry_valid;
            table_mem[table_write_addr].key         <= table_entry_key;
            table_mem[table_write_addr].mask        <= table_entry_mask;
            table_mem[table_write_addr].prefix_len  <= table_entry_prefix_len;
            table_mem[table_write_addr].action_id   <= table_entry_action_id;
            table_mem[table_write_addr].action_data <= table_entry_action_data;
        end
    end
    
    // ==========================================
    // Stage 1 - Register inputs
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            ipv4_valid_d1     <= 1'b0;
            eth_dst_d1        <= 48'b0;
            eth_src_d1        <= 48'b0;
            ipv4_ttl_d1       <= 8'b0;
            ipv4_diffserv_d1  <= 6'b0;
            ipv4_ecn_d1       <= 2'b0;
            packet_data_d1    <= '0;
            packet_keep_d1    <= '0;
            packet_last_d1    <= 1'b0;
            lookup_valid_d1   <= 1'b0;
            lookup_key_d1     <= '0;
            // Custom header register resets
{{MATCH_CUSTOM_HEADER_REG_RESETS}}
        end else if (lookup_ready) begin
            ipv4_valid_d1     <= ipv4_valid_in;
            eth_dst_d1        <= eth_dst_addr_in;
            eth_src_d1        <= eth_src_addr_in;
            ipv4_ttl_d1       <= ipv4_ttl_in;
            ipv4_diffserv_d1  <= ipv4_diffserv_in;
            ipv4_ecn_d1       <= ipv4_ecn_in;
            packet_data_d1    <= packet_data_in;
            packet_keep_d1    <= packet_keep_in;
            packet_last_d1    <= packet_last_in;
            lookup_valid_d1   <= lookup_valid;
            lookup_key_d1     <= lookup_key;
            // Custom header register assignments
{{MATCH_CUSTOM_HEADER_REG_ASSIGNS}}
        end
    end

    // ==========================================
    // Lookup Logic (Combinational)
    // ==========================================
    always_comb begin
        lookup_ready = 1'b1;  // Always ready for combinational lookup
    end
    
    // ==========================================
    // Match Logic (Uses registered inputs)
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            match_hit         <= 1'b0;
            match_action_id   <= 3'd1;  // Default drop
            match_action_data <= '0;
            match_valid       <= 1'b0;
            ipv4_valid_out    <= 1'b0;
            eth_dst_addr_out  <= 48'b0;
            eth_src_addr_out  <= 48'b0;
            ipv4_ttl_out      <= 8'b0;
            ipv4_diffserv_out <= 6'b0;
            ipv4_ecn_out      <= 2'b0;
            packet_data_out   <= '0;
            packet_keep_out   <= '0;
            packet_last_out   <= 1'b0;
            // Custom header output resets
{{MATCH_CUSTOM_HEADER_OUT_RESETS}}
        end else begin
            match_valid       <= lookup_valid_d1;
            ipv4_valid_out    <= ipv4_valid_d1;
            eth_dst_addr_out  <= eth_dst_d1;
            eth_src_addr_out  <= eth_src_d1;
            ipv4_ttl_out      <= ipv4_ttl_d1;
            ipv4_diffserv_out <= ipv4_diffserv_d1;
            ipv4_ecn_out      <= ipv4_ecn_d1;
            packet_data_out   <= packet_data_d1;
            packet_keep_out   <= packet_keep_d1;
            packet_last_out   <= packet_last_d1;
            // Custom header output assignments
{{MATCH_CUSTOM_HEADER_OUT_ASSIGNS}}

            if (lookup_valid_d1) begin
                // Default: no match
                match_hit        <= 1'b0;
                match_action_id  <= 3'd1;  // Drop
                match_action_data <= '0;
                
                case (MATCH_TYPE)
                    // ==========================================
                    // EXACT MATCH
                    // ==========================================
                    0: begin
                        for (int i = 0; i < TABLE_SIZE; i++) begin
                            if (table_mem[i].valid &&
                                (lookup_key_d1 == table_mem[i].key)) begin
                                match_hit         <= 1'b1;
                                match_action_id   <= table_mem[i].action_id;
                                match_action_data <= table_mem[i].action_data;
                            end
                        end
                    end
                    
                    // ==========================================
                    // LPM (Longest Prefix Match)
                    // ==========================================
                    1: begin
                        automatic logic [5:0] best_match_len = 6'd0;
                        automatic logic found = 1'b0;
                        automatic logic [2:0] best_action_id = 3'd1;
                        automatic logic [ACTION_DATA_WIDTH-1:0] best_action_data = '0;

                        for (int i = 0; i < TABLE_SIZE; i++) begin
                            if (table_mem[i].valid) begin
                                // Calculate MSB-based mask from prefix length (for big-endian/network order IPs)
                                // For IP routing: /8 means top 8 bits, so mask = 0xFF000000
                                // /24 means top 24 bits, so mask = 0xFFFFFF00
                                if (table_mem[i].prefix_len == 6'd0)
                                    match_mask = '0;
                                else if (table_mem[i].prefix_len >= KEY_WIDTH)
                                    match_mask = '1;
                                else
                                    match_mask = ({KEY_WIDTH{1'b1}} << (KEY_WIDTH - table_mem[i].prefix_len));

                                // Check if prefix matches (using pipelined lookup key)
                                if ((lookup_key_d1 & match_mask) == (table_mem[i].key & match_mask)) begin
                                    // Select longest match
                                    if (table_mem[i].prefix_len >= best_match_len) begin
                                        found             = 1'b1;
                                        best_match_len    = table_mem[i].prefix_len;
                                        best_action_id    = table_mem[i].action_id;
                                        best_action_data  = table_mem[i].action_data;
                                    end
                                end
                            end
                        end

                        match_hit         <= found;
                        match_action_id   <= best_action_id;
                        match_action_data <= best_action_data;
                    end
                    
                    // ==========================================
                    // TERNARY MATCH
                    // ==========================================
                    2: begin
                        for (int i = 0; i < TABLE_SIZE; i++) begin
                            if (table_mem[i].valid) begin
                                // Apply mask to both key and lookup (using pipelined key)
                                if ((lookup_key_d1 & table_mem[i].mask) ==
                                    (table_mem[i].key & table_mem[i].mask)) begin
                                    match_hit         <= 1'b1;
                                    match_action_id   <= table_mem[i].action_id;
                                    match_action_data <= table_mem[i].action_data;
                                end
                            end
                        end
                    end

                    // ==========================================
                    // RANGE MATCH
                    // ==========================================
                    3: begin
                        for (int i = 0; i < TABLE_SIZE; i++) begin
                            if (table_mem[i].valid) begin
                                // Range: key <= lookup <= mask (using pipelined key)
                                if ((lookup_key_d1 >= table_mem[i].key) &&
                                    (lookup_key_d1 <= table_mem[i].mask)) begin
                                    match_hit         <= 1'b1;
                                    match_action_id   <= table_mem[i].action_id;
                                    match_action_data <= table_mem[i].action_data;
                                end
                            end
                        end
                    end
                    
                    default: begin
                        match_hit <= 1'b0;
                    end
                endcase
            end
        end
    end

endmodule