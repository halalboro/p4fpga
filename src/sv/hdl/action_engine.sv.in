// =============================================================================
// Action Engine Module
// Executes P4 actions on packet headers based on match results.
// Modular architecture: uses hash_engine, register_array, encap_decap as needed.
// Generated by P4-FPGA Compiler
// =============================================================================

module action_engine #(
    // ==========================================
    // Configuration Parameters
    // ==========================================
    parameter DATA_WIDTH = 512,
    parameter ACTION_DATA_WIDTH = 128,
    parameter METADATA_WIDTH = 64,

    // Feature flags (set by compiler based on P4 program analysis)
    parameter ENABLE_HASH = 0,
    parameter ENABLE_REGISTERS = 0,
    parameter ENABLE_ENCAP = 0,
    parameter ENABLE_DECAP = 0,
    parameter ENABLE_ECN_MARKING = 0,
    parameter ENABLE_MULTICAST = 0,

    // Hash configuration
    parameter HASH_TYPE = 0,          // 0=CRC16, 1=CRC32, 2=XOR, 3=CSUM16
    parameter HASH_INPUT_WIDTH = 104,
    parameter HASH_OUTPUT_WIDTH = 16,

    // Register configuration
    parameter NUM_REGISTERS = 1024,
    parameter REGISTER_WIDTH = 32,

    // Stack configuration (for encap/decap)
    parameter STACK_DEPTH = 16,
    parameter STACK_ELEMENT_WIDTH = 64,

    // ECN threshold
    parameter [18:0] ECN_THRESHOLD = 19'd10
) (
    input  wire                           aclk,
    input  wire                           aresetn,

    // ==========================================
    // Packet Input (from Match Engine)
    // ==========================================
    input  wire [DATA_WIDTH-1:0]          packet_in,
    input  wire [DATA_WIDTH/8-1:0]        packet_keep_in,
    input  wire                           packet_last_in,
    input  wire                           packet_valid_in,
    output wire                           packet_ready_out,

    // ==========================================
    // Action Control (from Match Engine)
    // ==========================================
    input  wire [3:0]                     action_id,
    input  wire [ACTION_DATA_WIDTH-1:0]   action_data,
    input  wire                           match_hit,

    // ==========================================
    // Header Fields (from Match Engine)
    // ==========================================
    input  wire                           ipv4_valid,
    input  wire [47:0]                    eth_dst_addr_in,
    input  wire [47:0]                    eth_src_addr_in,
    input  wire [7:0]                     ipv4_ttl_in,
    input  wire [5:0]                     ipv4_diffserv_in,
    input  wire [1:0]                     ipv4_ecn_in,
    input  wire [31:0]                    ipv4_src_addr,
    input  wire [31:0]                    ipv4_dst_addr,
    input  wire [15:0]                    ipv4_src_port,
    input  wire [15:0]                    ipv4_dst_port,
    input  wire [7:0]                     ipv4_protocol,

    // ==========================================
    // Standard Metadata
    // ==========================================
    input  wire [8:0]                     ingress_port,
    input  wire [15:0]                    packet_length,
    input  wire [18:0]                    enq_qdepth,

    // ==========================================
    // Metadata Bus
    // ==========================================
    input  wire [METADATA_WIDTH-1:0]      metadata_in,
    output reg  [METADATA_WIDTH-1:0]      metadata_out,

{{ACTION_CUSTOM_INPUTS}}

{{STACK_POINTER_INPUTS}}
{{STACK_POINTER_OUTPUTS}}

    // ==========================================
    // Packet Output (to Deparser)
    // ==========================================
    output reg  [DATA_WIDTH-1:0]          packet_out,
    output reg  [DATA_WIDTH/8-1:0]        packet_keep_out,
    output reg                            packet_last_out,
    output reg                            packet_valid_out,
    input  wire                           packet_ready_in,

    // ==========================================
    // Action Results (to Deparser/Stats)
    // ==========================================
    output reg                            drop,
    output reg  [8:0]                     egress_port,
    output reg  [15:0]                    mcast_grp,
    output reg                            header_modified,
    output reg                            ecn_marked,

    // ==========================================
    // Modified Header Outputs
    // ==========================================
    output reg  [47:0]                    eth_dst_addr_out,
    output reg  [47:0]                    eth_src_addr_out,
    output reg  [5:0]                     ipv4_diffserv_out,
    output reg  [1:0]                     ipv4_ecn_out,
    output reg  [7:0]                     ipv4_ttl_out

{{ACTION_CUSTOM_OUTPUTS}}
);

    // ==========================================
    // Action ID Definitions
    // ==========================================
    localparam ACTION_DROP     = 4'd0;
    localparam ACTION_FORWARD  = 4'd1;
    localparam ACTION_MODIFY   = 4'd2;
    localparam ACTION_ENCAP    = 4'd3;
    localparam ACTION_DECAP    = 4'd4;
    localparam ACTION_MCAST    = 4'd5;

    // ==========================================
    // Internal Signals
    // ==========================================
    reg                           packet_valid_d1;
    reg  [DATA_WIDTH-1:0]         packet_data_d1;
    reg  [DATA_WIDTH/8-1:0]       packet_keep_d1;
    reg                           packet_last_d1;
    reg  [3:0]                    action_id_d1;
    reg  [ACTION_DATA_WIDTH-1:0]  action_data_d1;
    reg                           match_hit_d1;

    // Header pipeline
    reg                           ipv4_valid_d1;
    reg  [47:0]                   eth_dst_d1;
    reg  [47:0]                   eth_src_d1;
    reg  [7:0]                    ipv4_ttl_d1;
    reg  [5:0]                    ipv4_diffserv_d1;
    reg  [1:0]                    ipv4_ecn_d1;

    // Always ready (for now - can add backpressure later)
    assign packet_ready_out = packet_ready_in;

    // ==========================================
    // Hash Engine (Optional)
    // ==========================================
    wire [HASH_OUTPUT_WIDTH-1:0] flow_hash;
    wire                         hash_valid;

    generate
        if (ENABLE_HASH) begin : gen_hash
            hash_engine #(
                .HASH_TYPE(HASH_TYPE),
                .INPUT_WIDTH(HASH_INPUT_WIDTH),
                .OUTPUT_WIDTH(HASH_OUTPUT_WIDTH)
            ) hash_inst (
                .aclk(aclk),
                .aresetn(aresetn),
                .data_in({ipv4_src_addr, ipv4_dst_addr, ipv4_src_port, ipv4_dst_port, ipv4_protocol}),
                .valid_in(packet_valid_in),
                .ready_out(),
                .hash_out(flow_hash),
                .valid_out(hash_valid)
            );
        end else begin : gen_no_hash
            assign flow_hash = '0;
            assign hash_valid = 1'b0;
        end
    endgenerate

    // ==========================================
    // Register Array (Optional)
    // ==========================================
    wire [REGISTER_WIDTH-1:0] reg_read_data;
    reg                       reg_write_enable;
    reg  [REGISTER_WIDTH-1:0] reg_write_data;

    generate
        if (ENABLE_REGISTERS) begin : gen_registers
            register_array #(
                .NUM_REGISTERS(NUM_REGISTERS),
                .REGISTER_WIDTH(REGISTER_WIDTH)
            ) reg_inst (
                .aclk(aclk),
                .aresetn(aresetn),
                .addr(flow_hash[$clog2(NUM_REGISTERS)-1:0]),
                .write_data(reg_write_data),
                .write_enable(reg_write_enable),
                .read_data(reg_read_data),
                .rmw_addr('0),
                .rmw_operand('0),
                .rmw_op(3'd0),
                .rmw_enable(1'b0),
                .rmw_old_value(),
                .rmw_new_value()
            );
        end else begin : gen_no_registers
            assign reg_read_data = '0;
        end
    endgenerate

    // ==========================================
    // Stage 1: Register Inputs
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            packet_valid_d1   <= 1'b0;
            packet_data_d1    <= '0;
            packet_keep_d1    <= '0;
            packet_last_d1    <= 1'b0;
            action_id_d1      <= 4'd0;
            action_data_d1    <= '0;
            match_hit_d1      <= 1'b0;
            ipv4_valid_d1     <= 1'b0;
            eth_dst_d1        <= 48'b0;
            eth_src_d1        <= 48'b0;
            ipv4_ttl_d1       <= 8'd255;
            ipv4_diffserv_d1  <= 6'b0;
            ipv4_ecn_d1       <= 2'b0;
        end else if (packet_ready_in) begin
            packet_valid_d1   <= packet_valid_in;
            packet_data_d1    <= packet_in;
            packet_keep_d1    <= packet_keep_in;
            packet_last_d1    <= packet_last_in;
            action_id_d1      <= action_id;
            action_data_d1    <= action_data;
            match_hit_d1      <= match_hit;
            ipv4_valid_d1     <= ipv4_valid;
            eth_dst_d1        <= eth_dst_addr_in;
            eth_src_d1        <= eth_src_addr_in;
            ipv4_ttl_d1       <= ipv4_ttl_in;
            ipv4_diffserv_d1  <= ipv4_diffserv_in;
            ipv4_ecn_d1       <= ipv4_ecn_in;
        end
    end

    // ==========================================
    // Stage 2: Action Execution
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            packet_out        <= '0;
            packet_keep_out   <= '0;
            packet_last_out   <= 1'b0;
            packet_valid_out  <= 1'b0;
            drop              <= 1'b0;
            egress_port       <= 9'd0;
            mcast_grp         <= 16'd0;
            header_modified   <= 1'b0;
            ecn_marked        <= 1'b0;
            eth_dst_addr_out  <= 48'b0;
            eth_src_addr_out  <= 48'b0;
            ipv4_diffserv_out <= 6'b0;
            ipv4_ecn_out      <= 2'b0;
            ipv4_ttl_out      <= 8'd255;
            metadata_out      <= '0;
            reg_write_enable  <= 1'b0;
            reg_write_data    <= '0;
        end else begin
            // Default outputs
            packet_out        <= packet_data_d1;
            packet_keep_out   <= packet_keep_d1;
            packet_last_out   <= packet_last_d1;
            packet_valid_out  <= packet_valid_d1;
            drop              <= 1'b0;
            header_modified   <= 1'b0;
            ecn_marked        <= 1'b0;
            metadata_out      <= metadata_in;
            reg_write_enable  <= 1'b0;

            // Default: pass through headers
            eth_dst_addr_out  <= eth_dst_d1;
            eth_src_addr_out  <= eth_src_d1;
            ipv4_diffserv_out <= ipv4_diffserv_d1;
            ipv4_ecn_out      <= ipv4_ecn_d1;
            ipv4_ttl_out      <= ipv4_ttl_d1;

            if (packet_valid_d1) begin
                // ==========================================
                // Execute Action Based on action_id
                // ==========================================
                case (action_id_d1)
                    ACTION_DROP: begin
                        drop <= 1'b1;
                        egress_port <= 9'd0;
                    end

                    ACTION_FORWARD: begin
                        drop <= 1'b0;
                        // Extract egress port from action_data[8:0]
                        egress_port <= action_data_d1[8:0];
                        // Extract dst_mac from action_data[56:9] if present
                        if (action_data_d1[56:9] != 48'b0) begin
                            eth_dst_addr_out <= action_data_d1[56:9];
                            header_modified <= 1'b1;
                        end
                        // TTL decrement for IPv4
                        if (ipv4_valid_d1 && ipv4_ttl_d1 > 8'd1) begin
                            ipv4_ttl_out <= ipv4_ttl_d1 - 8'd1;
                            header_modified <= 1'b1;
                        end else if (ipv4_valid_d1 && ipv4_ttl_d1 <= 8'd1) begin
                            // TTL expired - drop
                            drop <= 1'b1;
                        end
                    end

                    ACTION_MODIFY: begin
                        drop <= 1'b0;
                        egress_port <= action_data_d1[8:0];
                        header_modified <= 1'b1;
                        // Apply modifications from action_data
                        // [8:0] = egress_port
                        // [56:9] = dst_mac (48 bits)
                        // [62:57] = diffserv (6 bits)
                        if (action_data_d1[56:9] != 48'b0) begin
                            eth_dst_addr_out <= action_data_d1[56:9];
                        end
                        if (action_data_d1[62:57] != 6'b0) begin
                            ipv4_diffserv_out <= action_data_d1[62:57];
                        end
                        // TTL decrement
                        if (ipv4_valid_d1 && ipv4_ttl_d1 > 8'd1) begin
                            ipv4_ttl_out <= ipv4_ttl_d1 - 8'd1;
                        end
                    end

                    ACTION_MCAST: begin
                        drop <= 1'b0;
                        egress_port <= 9'd0;  // Multicast uses mcast_grp
                        mcast_grp <= action_data_d1[15:0];
                    end

                    default: begin
                        // No match or unknown action - drop
                        if (!match_hit_d1) begin
                            drop <= 1'b1;
                        end else begin
                            drop <= 1'b0;
                            egress_port <= action_data_d1[8:0];
                        end
                    end
                endcase

                // ==========================================
                // ECN Marking (if enabled)
                // ==========================================
                if (ENABLE_ECN_MARKING && enq_qdepth > ECN_THRESHOLD) begin
                    if (ipv4_ecn_d1 == 2'b01 || ipv4_ecn_d1 == 2'b10) begin
                        ipv4_ecn_out <= 2'b11;  // CE (Congestion Experienced)
                        ecn_marked <= 1'b1;
                        header_modified <= 1'b1;
                    end
                end
            end
        end
    end

{{ACTION_CUSTOM_LOGIC}}

endmodule
