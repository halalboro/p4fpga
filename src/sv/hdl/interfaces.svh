// =============================================================================
// P4-FPGA Standard Interfaces
// Reusable interface definitions for modular P4 pipeline components
// Generated by P4-FPGA Compiler
// =============================================================================

`ifndef P4FPGA_INTERFACES_SVH
`define P4FPGA_INTERFACES_SVH

// =============================================================================
// Match Result Interface
// Used between match modules and action modules
// =============================================================================
interface match_result_if #(
    parameter ACTION_DATA_WIDTH = 128
);
    logic                           hit;
    logic [3:0]                     action_id;
    logic [ACTION_DATA_WIDTH-1:0]   action_data;
    logic                           valid;

    modport producer (output hit, action_id, action_data, valid);
    modport consumer (input  hit, action_id, action_data, valid);
endinterface

// =============================================================================
// Packet Stream Interface (AXI-Stream style)
// Used for packet data transfer between pipeline stages
// =============================================================================
interface packet_stream_if #(
    parameter DATA_WIDTH = 512
);
    logic [DATA_WIDTH-1:0]          data;
    logic [DATA_WIDTH/8-1:0]        keep;
    logic                           last;
    logic                           valid;
    logic                           ready;

    modport master (output data, keep, last, valid, input ready);
    modport slave  (input  data, keep, last, valid, output ready);
endinterface

// =============================================================================
// Header Fields Interface
// Standard L2-L4 header fields passed between modules
// =============================================================================
interface header_fields_if;
    logic                           ipv4_valid;
    logic [47:0]                    eth_dst_addr;
    logic [47:0]                    eth_src_addr;
    logic [15:0]                    eth_type;
    logic [7:0]                     ipv4_ttl;
    logic [5:0]                     ipv4_diffserv;
    logic [1:0]                     ipv4_ecn;
    logic [31:0]                    ipv4_src_addr;
    logic [31:0]                    ipv4_dst_addr;
    logic [15:0]                    ipv4_src_port;
    logic [15:0]                    ipv4_dst_port;
    logic [7:0]                     ipv4_protocol;
    logic [15:0]                    ipv4_total_len;
    logic [3:0]                     ipv4_ihl;

    modport producer (output ipv4_valid, eth_dst_addr, eth_src_addr, eth_type,
                             ipv4_ttl, ipv4_diffserv, ipv4_ecn,
                             ipv4_src_addr, ipv4_dst_addr,
                             ipv4_src_port, ipv4_dst_port, ipv4_protocol,
                             ipv4_total_len, ipv4_ihl);
    modport consumer (input  ipv4_valid, eth_dst_addr, eth_src_addr, eth_type,
                             ipv4_ttl, ipv4_diffserv, ipv4_ecn,
                             ipv4_src_addr, ipv4_dst_addr,
                             ipv4_src_port, ipv4_dst_port, ipv4_protocol,
                             ipv4_total_len, ipv4_ihl);
endinterface

// =============================================================================
// Stack Pointer Interface
// Used for header stack operations (push_front, pop_front)
// =============================================================================
interface stack_ptr_if #(
    parameter PTR_WIDTH = 4
);
    logic [PTR_WIDTH-1:0]           ptr_in;
    logic [PTR_WIDTH-1:0]           ptr_out;
    logic                           push_enable;
    logic                           pop_enable;

    modport controller (output ptr_in, push_enable, pop_enable, input ptr_out);
    modport stack      (input  ptr_in, push_enable, pop_enable, output ptr_out);
endinterface

// =============================================================================
// Register Access Interface
// Used for stateful register read/write operations
// =============================================================================
interface register_access_if #(
    parameter ADDR_WIDTH = 10,
    parameter DATA_WIDTH = 32
);
    logic [ADDR_WIDTH-1:0]          addr;
    logic [DATA_WIDTH-1:0]          write_data;
    logic                           write_enable;
    logic [DATA_WIDTH-1:0]          read_data;
    logic                           read_valid;

    modport master (output addr, write_data, write_enable, input read_data, read_valid);
    modport slave  (input  addr, write_data, write_enable, output read_data, read_valid);
endinterface

// =============================================================================
// Hash Engine Interface
// Used for flow hashing (ECMP, bloom filters, etc.)
// =============================================================================
interface hash_if #(
    parameter INPUT_WIDTH = 104,
    parameter OUTPUT_WIDTH = 32
);
    logic [INPUT_WIDTH-1:0]         data_in;
    logic                           valid_in;
    logic [OUTPUT_WIDTH-1:0]        hash_out;
    logic                           valid_out;
    logic                           ready;

    modport producer (output data_in, valid_in, input hash_out, valid_out, ready);
    modport consumer (input  data_in, valid_in, output hash_out, valid_out, ready);
endinterface

// =============================================================================
// Action Control Interface
// Control signals for action execution
// =============================================================================
interface action_control_if;
    logic                           drop;
    logic [8:0]                     egress_port;
    logic [15:0]                    mcast_grp;
    logic                           header_modified;
    logic                           ecn_marked;

    modport producer (output drop, egress_port, mcast_grp, header_modified, ecn_marked);
    modport consumer (input  drop, egress_port, mcast_grp, header_modified, ecn_marked);
endinterface

`endif // P4FPGA_INTERFACES_SVH
