module action #(
    // ==========================================
    // Configuration Parameters
    // ==========================================
    parameter DATA_WIDTH = 512,
    parameter ACTION_DATA_WIDTH = 128,
    parameter METADATA_WIDTH = 64,
    
    // Action configuration bitmask
    // [0] = FORWARD
    // [1] = DROP
    // [2] = MODIFY_HEADER
    // [3] = ENCAP
    // [4] = DECAP
    // [5] = HASH
    // [6] = SET_FIELD
    parameter [7:0] ACTION_CONFIG = 8'b00000111,  // Forward, Drop, Modify
    
    // Egress processing configuration
    // [0] = ENABLE_EGRESS
    // [1] = ENABLE_ECN_MARKING
    // [2] = ENABLE_STATEFUL (registers/counters)
    // [3] = ENABLE_MIRRORING
    // [4] = ENABLE_EGRESS_TABLE
    // [5] = ENABLE_PUSH_FRONT
    parameter [7:0] EGRESS_CONFIG = 8'b00000000,  // Disabled by default
    
    // Stateful configuration
    parameter NUM_REGISTERS = 1024,               // Number of stateful registers
    parameter REGISTER_WIDTH = 32,                // Width of each register
    
    // Egress register configuration
    parameter NUM_EGRESS_REGISTERS = 8,           // Per-port registers (MAX_PORTS)
    parameter EGRESS_REG_WIDTH = 32,              // Width of egress registers
    parameter TIME_WIDTH = 48,                    // Timestamp width
    
    // ECN threshold (queue depth)
    parameter [18:0] ECN_THRESHOLD = 19'd10,
    
    // Egress table configuration
    parameter EGRESS_TABLE_SIZE = 16,
    parameter EGRESS_ACTION_DATA_WIDTH = 64
) (
    input  wire                           aclk,
    input  wire                           aresetn,

{{STACK_POINTER_INPUTS}}      
{{STACK_POINTER_OUTPUTS}}     
    
    // ==========================================
    // Packet Input
    // ==========================================
    input  wire [DATA_WIDTH-1:0]          packet_in,
    input  wire [DATA_WIDTH/8-1:0]        packet_keep_in,
    input  wire                           packet_last_in,
    input  wire                           packet_valid,
    output reg                            packet_ready,
    
    // ==========================================
    // Metadata Input/Output
    // ==========================================
    input  wire [METADATA_WIDTH-1:0]      metadata_in,
    output reg  [METADATA_WIDTH-1:0]      metadata_out,

    // ==========================================
    // Action Control (Ingress)
    // ==========================================
    input  wire [3:0]                     action_id,
    input  wire [ACTION_DATA_WIDTH-1:0]   action_data,
    input  wire                           action_valid,
    
    // ==========================================
    // Ingress Header Fields (from match engine)
    // ==========================================
    input  wire                           ipv4_valid,
    input  wire [47:0]                    eth_dst_addr,
    input  wire [47:0]                    eth_src_addr,
    input  wire [7:0]                     ipv4_ttl,
    input  wire [31:0]                    ipv4_src_addr,
    input  wire [31:0]                    ipv4_dst_addr,
    input  wire [15:0]                    ipv4_src_port,
    input  wire [15:0]                    ipv4_dst_port,
    input  wire [7:0]                     ipv4_protocol,
    input  wire [5:0]                     ipv4_diffserv_in,
    input  wire [1:0]                     ipv4_ecn_in,
    
    // ==========================================
    // Hash Input (for stateful indexing)
    // ==========================================
    input  wire [31:0]                    flow_hash,
    
    // ==========================================
    // Egress Control Inputs
    // ==========================================
    input  wire [18:0]                    enq_qdepth,
    
    // Standard Metadata for Egress
    input  wire [8:0]                     egress_port_id,
    input  wire [15:0]                    packet_length_in,
    
    // Probe header valid (for link_monitor)
    input  wire                           probe_valid,
    input  wire [7:0]                     probe_hop_cnt,
    
    // ==========================================
    // Packet Output
    // ==========================================
    output reg  [DATA_WIDTH-1:0]          packet_out,
    output reg  [DATA_WIDTH/8-1:0]        packet_keep_out,
    output reg                            packet_last_out,
    output reg                            packet_out_valid,
    input  wire                           packet_out_ready,
    
    // ==========================================
    // Action Results
    // ==========================================
    output reg                            drop,
    output reg  [8:0]                     egress_port,
    output reg                            header_modified,
    output reg                            ecn_marked,
    output reg  [5:0]                     ipv4_diffserv_out,
    output reg  [1:0]                     ipv4_ecn_out,
    output reg  [7:0]                     ipv4_ttl_out,
    
    // Egress-modified probe_data fields
    output reg                            out_probe_data_valid,
    output reg  [6:0]                     out_probe_data_swid,
    output reg  [7:0]                     out_probe_data_port,
    output reg  [31:0]                    out_probe_data_byte_cnt,
    output reg  [TIME_WIDTH-1:0]          out_probe_data_last_time,
    output reg  [TIME_WIDTH-1:0]          out_probe_data_cur_time,
    output reg                            out_probe_data_bos,
    
    // Egress table programming
    input  wire                           egress_table_write_enable,
    input  wire [$clog2(EGRESS_TABLE_SIZE)-1:0] egress_table_write_addr,
    input  wire [2:0]                     egress_table_entry_action,
    input  wire [EGRESS_ACTION_DATA_WIDTH-1:0] egress_table_entry_data
);

    // ==========================================
    // Action ID Definitions (Ingress)
    // ==========================================
    localparam ACTION_FORWARD       = 4'd0;
    localparam ACTION_DROP          = 4'd1;
    localparam ACTION_NOACTION      = 4'd2;
    localparam ACTION_ENCAP         = 4'd3;
    localparam ACTION_DECAP         = 4'd4;
    localparam ACTION_HASH_SELECT   = 4'd5;
    localparam ACTION_CHECK_STATE   = 4'd6;
    localparam ACTION_UPDATE_STATE  = 4'd7;
    localparam ACTION_SET_FIELD     = 4'd8;
    localparam ACTION_HASH_COMPUTE  = 4'd9;
    
    // Egress Action IDs
    localparam EGRESS_ACTION_NOACTION  = 3'd0;
    localparam EGRESS_ACTION_SET_SWID  = 3'd1;
    
    // ==========================================
    // Configuration Bits
    // ==========================================
    localparam ENABLE_FORWARD       = ACTION_CONFIG[0];
    localparam ENABLE_DROP          = ACTION_CONFIG[1];
    localparam ENABLE_MODIFY_HEADER = ACTION_CONFIG[2];
    localparam ENABLE_ENCAP         = ACTION_CONFIG[3];
    localparam ENABLE_DECAP         = ACTION_CONFIG[4];
    localparam ENABLE_HASH          = ACTION_CONFIG[5];
    localparam ENABLE_SET_FIELD     = ACTION_CONFIG[6];
    
    // Egress configuration bits
    localparam ENABLE_EGRESS        = EGRESS_CONFIG[0];
    localparam ENABLE_ECN_MARKING   = EGRESS_CONFIG[1];
    localparam ENABLE_STATEFUL      = EGRESS_CONFIG[2];
    localparam ENABLE_MIRRORING     = EGRESS_CONFIG[3];
    localparam ENABLE_EGRESS_TABLE  = EGRESS_CONFIG[4];
    localparam ENABLE_PUSH_FRONT    = EGRESS_CONFIG[5];

    // ==========================================
    // Internal Timestamp Counter
    // ==========================================
    reg [TIME_WIDTH-1:0] global_timestamp;
    
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn)
            global_timestamp <= {TIME_WIDTH{1'b0}};
        else
            global_timestamp <= global_timestamp + 1;
    end

    // ==========================================
    // Internal Signals
    // ==========================================
    reg [DATA_WIDTH-1:0]     ingress_packet;
    reg [DATA_WIDTH-1:0]     egress_packet;
    reg [1:0]                ecn_bits;
    reg [METADATA_WIDTH-1:0] metadata_reg;
    
    // ==========================================
    // Ingress Stateful Register Interface Signals
    // ==========================================
    reg  [$clog2(NUM_REGISTERS)-1:0] stateful_reg_addr_in;
    reg  [REGISTER_WIDTH-1:0]        stateful_reg_write_data_in;
    reg                              stateful_reg_write_en_in;
    wire [REGISTER_WIDTH-1:0]        stateful_reg_read_data_out;
    
    // ==========================================
    // Egress Register Interface Signals
    // ==========================================
    reg  [$clog2(NUM_EGRESS_REGISTERS)-1:0] egress_reg_index_in;
    reg  [EGRESS_REG_WIDTH-1:0]             byte_cnt_write_data_in;
    reg                                     byte_cnt_write_en_in;
    reg  [TIME_WIDTH-1:0]                   last_time_write_data_in;
    reg                                     last_time_write_en_in;
    wire [EGRESS_REG_WIDTH-1:0]             byte_cnt_read_out;
    wire [TIME_WIDTH-1:0]                   last_time_read_out;
    
    // ==========================================
    // Egress Table Interface Signals
    // ==========================================
    wire [2:0]                              egress_action_id_out;
    wire [EGRESS_ACTION_DATA_WIDTH-1:0]     egress_action_data_out;

    // ==========================================
    // Ingress Stateful Register Array
    // ==========================================
    generate
        if (ENABLE_STATEFUL) begin : gen_stateful
            reg [REGISTER_WIDTH-1:0] state_registers [0:NUM_REGISTERS-1];
            
            initial begin
                for (int i = 0; i < NUM_REGISTERS; i++) begin
                    state_registers[i] = {REGISTER_WIDTH{1'b0}};
                end
            end
            
            // Combinational read
            assign stateful_reg_read_data_out = state_registers[stateful_reg_addr_in];
            
            // Sequential write
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    for (int i = 0; i < NUM_REGISTERS; i++) begin
                        state_registers[i] <= {REGISTER_WIDTH{1'b0}};
                    end
                end else if (stateful_reg_write_en_in) begin
                    state_registers[stateful_reg_addr_in] <= stateful_reg_write_data_in;
                end
            end
        end else begin : gen_no_stateful
            assign stateful_reg_read_data_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Egress Register Arrays
    // For link_monitor: byte_cnt_reg and last_time_reg
    // ==========================================
    generate
        if (ENABLE_EGRESS && ENABLE_STATEFUL) begin : gen_egress_registers
            reg [EGRESS_REG_WIDTH-1:0] byte_cnt_reg [0:NUM_EGRESS_REGISTERS-1];
            reg [TIME_WIDTH-1:0]       last_time_reg [0:NUM_EGRESS_REGISTERS-1];
            
            initial begin
                for (int j = 0; j < NUM_EGRESS_REGISTERS; j++) begin
                    byte_cnt_reg[j]  = {EGRESS_REG_WIDTH{1'b0}};
                    last_time_reg[j] = {TIME_WIDTH{1'b0}};
                end
            end
            
            // Combinational read
            assign byte_cnt_read_out  = byte_cnt_reg[egress_reg_index_in];
            assign last_time_read_out = last_time_reg[egress_reg_index_in];
            
            // Sequential write
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    for (int j = 0; j < NUM_EGRESS_REGISTERS; j++) begin
                        byte_cnt_reg[j]  <= {EGRESS_REG_WIDTH{1'b0}};
                        last_time_reg[j] <= {TIME_WIDTH{1'b0}};
                    end
                end else begin
                    if (byte_cnt_write_en_in)
                        byte_cnt_reg[egress_reg_index_in] <= byte_cnt_write_data_in;
                    if (last_time_write_en_in)
                        last_time_reg[egress_reg_index_in] <= last_time_write_data_in;
                end
            end
        end else begin : gen_no_egress_registers
            assign byte_cnt_read_out  = '0;
            assign last_time_read_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Egress Table (swid table)
    // ==========================================
    generate
        if (ENABLE_EGRESS && ENABLE_EGRESS_TABLE) begin : gen_egress_table
            typedef struct packed {
                logic                              valid;
                logic [2:0]                        action_id;
                logic [EGRESS_ACTION_DATA_WIDTH-1:0] action_data;
            } egress_table_entry_t;
            
            egress_table_entry_t egress_table [0:EGRESS_TABLE_SIZE-1];
            
            // Table lookup result (internal)
            reg [2:0]                        egress_action_id;
            reg [EGRESS_ACTION_DATA_WIDTH-1:0] egress_action_data;
            reg                              egress_table_hit;
            
            initial begin
                for (int k = 0; k < EGRESS_TABLE_SIZE; k++) begin
                    egress_table[k].valid = 1'b0;
                    egress_table[k].action_id = 3'd0;
                    egress_table[k].action_data = '0;
                end
            end
            
            // Table write
            always_ff @(posedge aclk) begin
                if (egress_table_write_enable) begin
                    egress_table[egress_table_write_addr].valid      <= 1'b1;
                    egress_table[egress_table_write_addr].action_id  <= egress_table_entry_action;
                    egress_table[egress_table_write_addr].action_data <= egress_table_entry_data;
                end
            end
            
            // Table lookup (default entry at index 0)
            always_comb begin
                if (egress_table[0].valid) begin
                    egress_table_hit   = 1'b1;
                    egress_action_id   = egress_table[0].action_id;
                    egress_action_data = egress_table[0].action_data;
                end else begin
                    egress_table_hit   = 1'b0;
                    egress_action_id   = EGRESS_ACTION_NOACTION;
                    egress_action_data = '0;
                end
            end
            
            // Interface signals
            assign egress_action_id_out   = egress_action_id;
            assign egress_action_data_out = egress_action_data;
        end else begin : gen_no_egress_table
            assign egress_action_id_out   = EGRESS_ACTION_NOACTION;
            assign egress_action_data_out = '0;
        end
    endgenerate
    
    // ==========================================
    // Backpressure
    // ==========================================
    always_comb begin
        packet_ready = packet_out_ready;
    end
    
    // ==========================================
    // Action Execution (Unified Pipeline)
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            packet_out        <= '0;
            packet_keep_out   <= '0;
            packet_last_out   <= 1'b0;
            packet_out_valid  <= 1'b0;
            drop              <= 1'b0;
            egress_port       <= 9'd0;
            header_modified   <= 1'b0;
            ecn_marked        <= 1'b0;
            ipv4_diffserv_out <= 6'b0;
            ipv4_ecn_out      <= 2'b0;
            ipv4_ttl_out      <= 8'b0;
            metadata_out      <= '0;
            
            // Reset egress outputs
            out_probe_data_valid     <= 1'b0;
            out_probe_data_swid      <= 7'd0;
            out_probe_data_port      <= 8'd0;
            out_probe_data_byte_cnt  <= 32'd0;
            out_probe_data_last_time <= {TIME_WIDTH{1'b0}};
            out_probe_data_cur_time  <= {TIME_WIDTH{1'b0}};
            out_probe_data_bos       <= 1'b0;
            
            // Reset interface signals
            stateful_reg_addr_in       <= '0;
            stateful_reg_write_data_in <= '0;
            stateful_reg_write_en_in   <= 1'b0;
            egress_reg_index_in        <= '0;
            byte_cnt_write_data_in     <= '0;
            byte_cnt_write_en_in       <= 1'b0;
            last_time_write_data_in    <= '0;
            last_time_write_en_in      <= 1'b0;

{{STACK_POINTER_RESET_OUT}}

        end else if (packet_ready) begin
            packet_out_valid  <= packet_valid && action_valid;
            packet_keep_out   <= packet_keep_in;
            packet_last_out   <= packet_last_in;
            
            // Default: pass through header fields
            ipv4_diffserv_out <= ipv4_diffserv_in;
            ipv4_ecn_out      <= ipv4_ecn_in;
            ipv4_ttl_out      <= ipv4_ttl;
            metadata_reg      <= metadata_in;
            
            // Default: no writes
            stateful_reg_write_en_in <= 1'b0;
            byte_cnt_write_en_in     <= 1'b0;
            last_time_write_en_in    <= 1'b0;

            // Default: no probe data output
            out_probe_data_valid <= 1'b0;
            
            if (packet_valid && action_valid) begin
                // ============================================
                // STAGE 1: INGRESS PROCESSING
                // ============================================
                
                ingress_packet  = packet_in;
                drop            = 1'b0;
                egress_port     = 9'd0;
                header_modified = 1'b0;
                
                case (action_id)
{{STACK_POINTER_LOGIC_INOUT}}

                    // ==========================================
                    // FORWARD Action
                    // ==========================================
                    ACTION_FORWARD: begin
                        if (ENABLE_FORWARD && ENABLE_MODIFY_HEADER) begin
                            if (ipv4_valid) begin
                                ingress_packet[47:0] = action_data[47:0];
                                ingress_packet[95:48] = eth_dst_addr;
                                
                                if (ipv4_ttl > 8'd0) begin
                                    ingress_packet[183:176] = ipv4_ttl - 8'd1;
                                    ipv4_ttl_out    = ipv4_ttl - 8'd1;
                                    egress_port     = action_data[56:48];
                                    header_modified = 1'b1;
                                end else begin
                                    drop = 1'b1;
                                end
                            end else begin
                                drop = 1'b1;
                            end
                        end
                    end
                    
                    // ==========================================
                    // DROP Action
                    // ==========================================
                    ACTION_DROP: begin
                        if (ENABLE_DROP) begin
                            drop = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // NOACTION
                    // ==========================================
                    ACTION_NOACTION: begin
                        drop            = 1'b0;
                        header_modified = 1'b0;
                    end
                    
                    // ==========================================
                    // CHECK_STATE Action (for firewall)
                    // ==========================================
                    ACTION_CHECK_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            stateful_reg_addr_in = flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            if (stateful_reg_read_data_out == 32'd0) begin
                                drop = 1'b1;
                            end else begin
                                drop = 1'b0;
                            end
                        end
                    end
                    
                    // ==========================================
                    // UPDATE_STATE Action (for firewall)
                    // ==========================================
                    ACTION_UPDATE_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            stateful_reg_addr_in       = flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            stateful_reg_write_data_in = 32'd1;
                            stateful_reg_write_en_in   = 1'b1;
                            drop            = 1'b0;
                            header_modified = 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // ENCAP Action (for tunneling)
                    // ==========================================
                    ACTION_ENCAP: begin
                        if (ENABLE_ENCAP) begin
                            // Shift packet and prepend tunnel header
                            // Implementation depends on tunnel type
                            header_modified = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // DECAP Action (for tunneling)
                    // ==========================================
                    ACTION_DECAP: begin
                        if (ENABLE_DECAP) begin
                            // Remove outer header
                            // Implementation depends on tunnel type
                            header_modified = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // HASH_COMPUTE Action (for load balancing)
                    // ==========================================
                    ACTION_HASH_COMPUTE: begin
                        if (ENABLE_HASH) begin
                            // Write hash to metadata[31:0] (first 32 bits)
                            metadata_reg[31:0] = flow_hash;
                            
                            // Use hash to select egress port
                            egress_port = flow_hash[8:0];  // Bottom 9 bits
                            
                            drop = 1'b0;
                            header_modified = 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // SET_FIELD Action (for QoS)
                    // ==========================================
                    ACTION_SET_FIELD: begin
                        if (ENABLE_SET_FIELD) begin
                            // action_data layout for SET_FIELD:
                            // [7:0]   = field_id (which field to modify)
                            // [15:8]  = field_value (value to set)
                            
                            automatic logic [7:0] field_id;
                            automatic logic [7:0] field_value;
                            
                            field_id = action_data[7:0];
                            field_value = action_data[15:8];
                            
                            case (field_id)
                                8'd0: begin  // FIELD_DIFFSERV
                                    ipv4_diffserv_out = field_value[5:0];
                                    header_modified = 1'b1;
                                end
                                8'd1: begin  // FIELD_ECN
                                    ipv4_ecn_out = field_value[1:0];
                                    header_modified = 1'b1;
                                end
                                8'd2: begin  // FIELD_TTL
                                    ipv4_ttl_out = field_value;
                                    header_modified = 1'b1;
                                end
                                default: begin
                                    // Unknown field, pass through
                                    header_modified = 1'b0;
                                end
                            endcase
                            
                            drop = 1'b0;
                            egress_port = 9'd0;  // No egress port change
                        end
                    end

                    default: begin
                        // Unknown action: drop for safety
                        drop = 1'b1;
                    end
                endcase
                
                // ============================================
                // STAGE 2: EGRESS PROCESSING 
                // ============================================
                
                egress_packet = ingress_packet;
                ecn_marked    = 1'b0;
                
                if (ENABLE_EGRESS && !drop) begin
                    
                    // ------------------------------------------
                    // ECN MARKING LOGIC
                    // ------------------------------------------
                    if (ENABLE_ECN_MARKING && ipv4_valid) begin
                        ecn_bits = ipv4_ecn_in;
                        if (ecn_bits == 2'b01 || ecn_bits == 2'b10) begin
                            if (enq_qdepth >= ECN_THRESHOLD) begin
                                ipv4_ecn_out    = 2'b11;
                                header_modified = 1'b1;
                                ecn_marked      = 1'b1;
                            end
                        end
                    end
                    
                    // ------------------------------------------
                    // EGRESS REGISTER OPERATIONS
                    // (link_monitor.p4 byte counting logic)
                    // ------------------------------------------
                    if (ENABLE_STATEFUL) begin
                        egress_reg_index_in <= egress_port_id[$clog2(NUM_EGRESS_REGISTERS)-1:0];
                        
                        begin
                            reg [EGRESS_REG_WIDTH-1:0] current_byte_cnt;
                            reg [EGRESS_REG_WIDTH-1:0] new_byte_cnt;
                            
                            current_byte_cnt = byte_cnt_read_out;
                            new_byte_cnt = current_byte_cnt + {16'd0, packet_length_in};
                            
                            if (probe_valid) begin
                                out_probe_data_byte_cnt <= current_byte_cnt;
                                byte_cnt_write_data_in  <= 32'd0;
                                byte_cnt_write_en_in    <= 1'b1;
                                
                                out_probe_data_last_time <= last_time_read_out;
                                out_probe_data_cur_time  <= global_timestamp;
                                last_time_write_data_in  <= global_timestamp;
                                last_time_write_en_in    <= 1'b1;
                                
                                out_probe_data_port  <= egress_port_id[7:0];
                                out_probe_data_bos   <= (probe_hop_cnt == 8'd1);
                                out_probe_data_valid <= 1'b1;
                                header_modified      <= 1'b1;
                            end else begin
                                byte_cnt_write_data_in <= new_byte_cnt;
                                byte_cnt_write_en_in   <= 1'b1;
                            end
                        end
                    end
                    
                    // ------------------------------------------
                    // EGRESS TABLE (swid)
                    // ------------------------------------------
                    if (ENABLE_EGRESS_TABLE && probe_valid) begin
                        case (egress_action_id_out)
                            EGRESS_ACTION_SET_SWID: begin
                                out_probe_data_swid <= egress_action_data_out[6:0];
                            end
                            default: begin
                                out_probe_data_swid <= 7'd0;
                            end
                        endcase
                    end
                    
                    // ------------------------------------------
                    // MIRRORING LOGIC (placeholder)
                    // ------------------------------------------
                    if (ENABLE_MIRRORING) begin
                        // Future: Clone packet to mirror port
                    end
                end
                
                // Output final packet
                packet_out   = egress_packet;
                metadata_out = metadata_reg;
            end
        end
    end

endmodule

// ============================================================================
// hash.sv
// Hardware hash computation module
// Supports CRC16, CRC32, and XOR hashing for load balancing and flow identification
// ============================================================================

module hash #(
    parameter HASH_TYPE = 0,     // 0=CRC16, 1=CRC32, 2=XOR
    parameter INPUT_WIDTH = 104, // 5-tuple = 104 bits (default)
    parameter OUTPUT_WIDTH = 16  // Output hash width
) (
    input  wire                        aclk,
    input  wire                        aresetn,
    
    // Input data interface
    input  wire [INPUT_WIDTH-1:0]      data_in,
    input  wire                        valid_in,
    output wire                        ready_out,
    
    // Output hash interface
    output reg  [OUTPUT_WIDTH-1:0]     hash_out,
    output reg                         valid_out
);

    // ==========================================
    // CRC Polynomials
    // ==========================================
    // CRC16-CCITT: x^16 + x^12 + x^5 + 1
    localparam [15:0] CRC16_POLY = 16'h1021;
    
    // CRC32-Ethernet: x^32 + x^26 + x^23 + ... + x^2 + x + 1
    localparam [31:0] CRC32_POLY = 32'h04C11DB7;
    
    // ==========================================
    // Hash Type Generation
    // ==========================================
    generate
        // ==========================================
        // CRC16 Hash (Optimized for Synthesis)
        // ==========================================
        if (HASH_TYPE == 0) begin : gen_crc16
            
            // Internal CRC register
            reg [15:0] crc_reg;
            
            // Sequential CRC computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    crc_reg   <= 16'hFFFF;
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    // Compute CRC in one cycle using function
                    crc_reg   <= compute_crc16(data_in);
                    hash_out  <= compute_crc16(data_in)[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // CRC16 Computation Function (Byte-wise)
            // Processes 8 bits at a time for better timing
            // ==========================================
            function [15:0] compute_crc16(input [INPUT_WIDTH-1:0] data);
                reg [15:0] crc;
                reg [15:0] crc_next;
                reg [7:0] data_byte;
                integer byte_idx, bit_idx;
                integer num_bytes;
                begin
                    // Initialize CRC
                    crc = 16'hFFFF;
                    num_bytes = (INPUT_WIDTH + 7) / 8;
                    
                    // Process each byte
                    for (byte_idx = 0; byte_idx < num_bytes; byte_idx = byte_idx + 1) begin
                        // Extract byte (handle partial last byte)
                        if ((byte_idx + 1) * 8 <= INPUT_WIDTH) begin
                            data_byte = data[byte_idx*8 +: 8];
                        end else begin
                            // Last partial byte - pad with zeros
                            data_byte = {data[INPUT_WIDTH-1 : byte_idx*8], 
                                       {(8-(INPUT_WIDTH % 8)){1'b0}}};
                        end
                        
                        // XOR byte into CRC
                        crc_next = crc ^ {data_byte, 8'h00};
                        
                        // Process each bit using polynomial division
                        for (bit_idx = 0; bit_idx < 8; bit_idx = bit_idx + 1) begin
                            if (crc_next[15]) begin
                                crc_next = {crc_next[14:0], 1'b0} ^ CRC16_POLY;
                            end else begin
                                crc_next = {crc_next[14:0], 1'b0};
                            end
                        end
                        
                        crc = crc_next;
                    end
                    
                    compute_crc16 = ~crc;  // Final XOR (standard practice)
                end
            endfunction
            
        // ==========================================
        // CRC32 Hash (Optimized for Synthesis)
        // ==========================================
        end else if (HASH_TYPE == 1) begin : gen_crc32
            
            // Internal CRC register
            reg [31:0] crc_reg;
            
            // Sequential CRC computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    crc_reg   <= 32'hFFFFFFFF;
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    // Compute CRC in one cycle using function
                    crc_reg   <= compute_crc32(data_in);
                    hash_out  <= compute_crc32(data_in)[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // CRC32 Computation Function (Byte-wise)
            // ==========================================
            function [31:0] compute_crc32(input [INPUT_WIDTH-1:0] data);
                reg [31:0] crc;
                reg [31:0] crc_next;
                reg [7:0] data_byte;
                integer byte_idx, bit_idx;
                integer num_bytes;
                begin
                    // Initialize CRC
                    crc = 32'hFFFFFFFF;
                    num_bytes = (INPUT_WIDTH + 7) / 8;
                    
                    // Process each byte
                    for (byte_idx = 0; byte_idx < num_bytes; byte_idx = byte_idx + 1) begin
                        // Extract byte (handle partial last byte)
                        if ((byte_idx + 1) * 8 <= INPUT_WIDTH) begin
                            data_byte = data[byte_idx*8 +: 8];
                        end else begin
                            // Last partial byte - pad with zeros
                            data_byte = {data[INPUT_WIDTH-1 : byte_idx*8], 
                                       {(8-(INPUT_WIDTH % 8)){1'b0}}};
                        end
                        
                        // XOR byte into CRC (reflected input)
                        crc_next = crc ^ {24'h000000, data_byte};
                        
                        // Process each bit using polynomial division
                        for (bit_idx = 0; bit_idx < 8; bit_idx = bit_idx + 1) begin
                            if (crc_next[0]) begin
                                crc_next = {1'b0, crc_next[31:1]} ^ CRC32_POLY;
                            end else begin
                                crc_next = {1'b0, crc_next[31:1]};
                            end
                        end
                        
                        crc = crc_next;
                    end
                    
                    compute_crc32 = ~crc;  // Final XOR
                end
            endfunction
            
        // ==========================================
        // XOR Hash (Simplest, Fastest)
        // ==========================================
        end else begin : gen_xor
            
            // Sequential XOR computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    hash_out  <= xor_reduce(data_in);
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // XOR Reduction Function
            // Folds all input bits into OUTPUT_WIDTH bits
            // ==========================================
            function [OUTPUT_WIDTH-1:0] xor_reduce(input [INPUT_WIDTH-1:0] data);
                reg [OUTPUT_WIDTH-1:0] result;
                integer i;
                begin
                    result = {OUTPUT_WIDTH{1'b0}};
                    
                    // XOR all input bits into output width buckets
                    for (i = 0; i < INPUT_WIDTH; i = i + 1) begin
                        result[i % OUTPUT_WIDTH] = result[i % OUTPUT_WIDTH] ^ data[i];
                    end
                    
                    xor_reduce = result;
                end
            endfunction
            
        end
    endgenerate
    
    // ==========================================
    // Always ready (single-cycle operation)
    // ==========================================
    assign ready_out = 1'b1;

endmodule