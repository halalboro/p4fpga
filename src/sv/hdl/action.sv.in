// action.sv
// Generic action execution engine
// Supports multiple action types via configuration
// Added stateful register support for connection tracking

module action #(
    // ==========================================
    // Configuration Parameters
    // ==========================================
    parameter DATA_WIDTH = 512,
    parameter ACTION_DATA_WIDTH = 128,
    parameter METADATA_WIDTH = 64,
    
    // Action configuration bitmask
    // [0] = FORWARD
    // [1] = DROP
    // [2] = MODIFY_HEADER
    // [3] = ENCAP
    // [4] = DECAP
    // [5] = HASH
    // [6] = SET_FIELD
    parameter [7:0] ACTION_CONFIG = 8'b00000111,  // Forward, Drop, Modify
    
    // Egress processing configuration
    // [0] = ENABLE_EGRESS
    // [1] = ENABLE_ECN_MARKING
    // [2] = ENABLE_STATEFUL (registers/counters)
    // [3] = ENABLE_MIRRORING
    parameter [7:0] EGRESS_CONFIG = 8'b00000000,  // Disabled by default
    
    // Stateful configuration
    parameter NUM_REGISTERS = 1024,               // Number of stateful registers
    parameter REGISTER_WIDTH = 32,                // Width of each register
    
    // ECN threshold (queue depth)
    parameter [18:0] ECN_THRESHOLD = 19'd10
) (
    input  wire                           aclk,
    input  wire                           aresetn,\
    

{{STACK_POINTER_INPUTS}}      
{{STACK_POINTER_OUTPUTS}}     
    
    // ==========================================
    // Packet Input
    // ==========================================
    input  wire [DATA_WIDTH-1:0]          packet_in,
    input  wire [DATA_WIDTH/8-1:0]        packet_keep_in,
    input  wire                           packet_last_in,
    input  wire                           packet_valid,
    output reg                            packet_ready,
    
    // ==========================================
    // Metadata Input/Output
    // ==========================================
    input  wire [METADATA_WIDTH-1:0]      metadata_in,
    output reg  [METADATA_WIDTH-1:0]      metadata_out,

    // ==========================================
    // Action Control
    // ==========================================
    input  wire [2:0]                     action_id,
    input  wire [ACTION_DATA_WIDTH-1:0]   action_data,
    input  wire                           action_valid,
    
    // ==========================================
    // Ingress Header Fields (from match engine - PRESERVED)
    // ==========================================
    input  wire                           ipv4_valid,
    input  wire [47:0]                    eth_dst_addr,
    input  wire [47:0]                    eth_src_addr,
    input  wire [7:0]                     ipv4_ttl,
    input  wire [31:0]                    ipv4_src_addr,
    input  wire [31:0]                    ipv4_dst_addr,
    input  wire [15:0]                    ipv4_src_port,    // TCP/UDP src port
    input  wire [15:0]                    ipv4_dst_port,    // TCP/UDP dst port
    input  wire [7:0]                     ipv4_protocol,    // Protocol (TCP/UDP)
    input  wire [5:0]                     ipv4_diffserv_in,
    input  wire [1:0]                     ipv4_ecn_in,
    
    // ==========================================
    // Hash Input (for stateful indexing)
    // ==========================================
    input  wire [31:0]                    flow_hash,        // 5-tuple hash
    
    // ==========================================
    // Egress Control Inputs (for egress processing)
    // ==========================================
    input  wire [18:0]                    enq_qdepth,       // Queue depth
    
    // ==========================================
    // Packet Output
    // ==========================================
    output reg  [DATA_WIDTH-1:0]          packet_out,
    output reg  [DATA_WIDTH/8-1:0]        packet_keep_out,
    output reg                            packet_last_out,
    output reg                            packet_out_valid,
    input  wire                           packet_out_ready,
    
    // ==========================================
    // Action Results
    // ==========================================
    output reg                            drop,
    output reg  [8:0]                     egress_port,
    output reg                            header_modified,
    output reg                            ecn_marked,
    output reg  [5:0]                     ipv4_diffserv_out,
    output reg  [1:0]                     ipv4_ecn_out,
    output reg  [7:0]                     ipv4_ttl_out
);

    // ==========================================
    // Action ID Definitions
    // ==========================================
    localparam ACTION_FORWARD       = 3'd0;
    localparam ACTION_DROP          = 3'd1;
    localparam ACTION_NOACTION      = 3'd2;
    localparam ACTION_ENCAP         = 3'd3;
    localparam ACTION_DECAP         = 3'd4;
    localparam ACTION_HASH_SELECT   = 3'd5;
    localparam ACTION_CHECK_STATE   = 3'd6;
    localparam ACTION_UPDATE_STATE  = 3'd7;
    localparam ACTION_SET_FIELD     = 3'd8;
    localparam ACTION_HASH_COMPUTE = 3'd9;
    
    // ==========================================
    // Configuration Bits
    // ==========================================
    localparam ENABLE_FORWARD       = ACTION_CONFIG[0];
    localparam ENABLE_DROP          = ACTION_CONFIG[1];
    localparam ENABLE_MODIFY_HEADER = ACTION_CONFIG[2];
    localparam ENABLE_ENCAP         = ACTION_CONFIG[3];
    localparam ENABLE_DECAP         = ACTION_CONFIG[4];
    localparam ENABLE_HASH          = ACTION_CONFIG[5];
    localparam ENABLE_SET_FIELD     = ACTION_CONFIG[6];
    
    // Egress configuration bits
    localparam ENABLE_EGRESS        = EGRESS_CONFIG[0];
    localparam ENABLE_ECN_MARKING   = EGRESS_CONFIG[1];
    localparam ENABLE_STATEFUL      = EGRESS_CONFIG[2];
    localparam ENABLE_MIRRORING     = EGRESS_CONFIG[3];

    
    // ==========================================
    // Internal Signals
    // ==========================================
    reg [DATA_WIDTH-1:0] ingress_packet;  // After ingress processing
    reg [DATA_WIDTH-1:0] egress_packet;   // After egress processing
    reg [1:0]            ecn_bits;        // ECN field working copy
    reg [METADATA_WIDTH-1:0] metadata_reg;  // Metadata working copy
    
    // ==========================================
    // Stateful Register Array
    // ==========================================
    generate
        if (ENABLE_STATEFUL) begin : gen_stateful
            // Register array for connection state
            reg [REGISTER_WIDTH-1:0] state_registers [0:NUM_REGISTERS-1];
            
            // Register access signals
            reg  [$clog2(NUM_REGISTERS)-1:0] reg_addr;
            reg  [REGISTER_WIDTH-1:0]        reg_read_data;
            reg  [REGISTER_WIDTH-1:0]        reg_write_data;
            reg                              reg_write_enable;
            
            // Initialize registers to 0
            integer i;
            initial begin
                for (i = 0; i < NUM_REGISTERS; i = i + 1) begin
                    state_registers[i] = {REGISTER_WIDTH{1'b0}};
                end
            end
            
            // Register read/write logic
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    reg_read_data <= '0;
                end else begin
                    // Read
                    reg_read_data <= state_registers[reg_addr];
                    
                    // Write
                    if (reg_write_enable) begin
                        state_registers[reg_addr] <= reg_write_data;
                    end
                end
            end
        end else begin : gen_no_stateful
            // Dummy signals when stateful is disabled
            wire [$clog2(NUM_REGISTERS)-1:0] reg_addr = '0;
            wire [REGISTER_WIDTH-1:0]        reg_read_data = '0;
            wire [REGISTER_WIDTH-1:0]        reg_write_data = '0;
            wire                             reg_write_enable = 1'b0;
        end
    endgenerate
    
    // ==========================================
    // Backpressure
    // ==========================================
    always_comb begin
        packet_ready = packet_out_ready;
    end
    
    // ==========================================
    // Action Execution (Unified Pipeline)
    // ==========================================
    always_ff @(posedge aclk or negedge aresetn) begin
        if (!aresetn) begin
            packet_out        <= '0;
            packet_keep_out   <= '0;
            packet_last_out   <= 1'b0;
            packet_out_valid  <= 1'b0;
            drop              <= 1'b0;
            egress_port       <= 9'd0;
            header_modified   <= 1'b0;
            ecn_marked        <= 1'b0;
            ipv4_diffserv_out <= 6'b0;
            ipv4_ecn_out      <= 2'b0;
            ipv4_ttl_out      <= 8'b0;
            metadata_out      <= '0;
            
            if (ENABLE_STATEFUL) begin
                gen_stateful.reg_addr         <= '0;
                gen_stateful.reg_write_data   <= '0;
                gen_stateful.reg_write_enable <= 1'b0;
            end

            {{STACK_POINTER_RESET_OUT}}

        end else if (packet_ready) begin
            packet_out_valid  <= packet_valid && action_valid;
            packet_keep_out   <= packet_keep_in;
            packet_last_out   <= packet_last_in;
            
            // Default: pass through header fields
            ipv4_diffserv_out <= ipv4_diffserv_in;
            ipv4_ecn_out      <= ipv4_ecn_in;
            ipv4_ttl_out      <= ipv4_ttl;
        
            // Default metadata pass-through
            metadata_reg      <= metadata_in;
            
            // Default: no register write
            if (ENABLE_STATEFUL) begin
                gen_stateful.reg_write_enable <= 1'b0;
            end
            
            if (packet_valid && action_valid) begin
                // ============================================
                // STAGE 1: INGRESS PROCESSING
                // ============================================
                
                // Default: pass through
                ingress_packet  = packet_in;
                drop            = 1'b0;
                egress_port     = 9'd0;
                header_modified = 1'b0;
                
                case (action_id)
                {{STACK_POINTER_LOGIC_INOUT}}

                    // ==========================================
                    // FORWARD Action
                    // ==========================================
                    ACTION_FORWARD: begin
                        if (ENABLE_FORWARD && ENABLE_MODIFY_HEADER) begin
                            // Check ipv4_valid before modifying
                            if (ipv4_valid) begin
                                // Modify Ethernet destination MAC
                                ingress_packet[47:0] = action_data[47:0];  // New dst MAC
                                
                                // Swap source MAC (old dst becomes new src)
                                ingress_packet[95:48] = eth_dst_addr;
                                
                                // Decrement TTL
                                if (ipv4_ttl > 8'd0) begin
                                    ingress_packet[183:176] = ipv4_ttl - 8'd1;
                                    ipv4_ttl_out    = ipv4_ttl - 8'd1;
                                    egress_port     = action_data[56:48];
                                    header_modified = 1'b1;
                                end else begin
                                    drop = 1'b1;  // TTL expired
                                end
                            end else begin
                                // No IPv4 header, cannot forward
                                drop = 1'b1;
                            end
                        end
                    end
                    
                    // ==========================================
                    // DROP Action
                    // ==========================================
                    ACTION_DROP: begin
                        if (ENABLE_DROP) begin
                            drop = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // NOACTION
                    // ==========================================
                    ACTION_NOACTION: begin
                        // Pass through unchanged
                        drop            = 1'b0;
                        header_modified = 1'b0;
                    end
                    
                    // ==========================================
                    // CHECK_STATE Action (for firewall)
                    // ==========================================
                    ACTION_CHECK_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            // Use flow hash to index into register array
                            gen_stateful.reg_addr = flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            
                            // Read register value (available next cycle due to FF)
                            if (gen_stateful.reg_read_data == 32'd0) begin
                                drop = 1'b1;  // No connection found
                            end else begin
                                drop = 1'b0;  // Connection exists
                            end
                        end
                    end
                    
                    // ==========================================
                    // UPDATE_STATE Action (for firewall)
                    // ==========================================
                    ACTION_UPDATE_STATE: begin
                        if (ENABLE_STATEFUL) begin
                            // Use flow hash to index into register array
                            gen_stateful.reg_addr = flow_hash[$clog2(NUM_REGISTERS)-1:0];
                            
                            // Write connection state (e.g., timestamp)
                            gen_stateful.reg_write_data   = 32'd1;  // Mark as active
                            gen_stateful.reg_write_enable = 1'b1;
                            
                            drop            = 1'b0;
                            header_modified = 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // ENCAP Action (for tunneling)
                    // ==========================================
                    ACTION_ENCAP: begin
                        if (ENABLE_ENCAP) begin
                            // Shift packet and prepend tunnel header
                            // Implementation depends on tunnel type
                            header_modified = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // DECAP Action (for tunneling)
                    // ==========================================
                    ACTION_DECAP: begin
                        if (ENABLE_DECAP) begin
                            // Remove outer header
                            // Implementation depends on tunnel type
                            header_modified = 1'b1;
                        end
                    end
                    
                    // ==========================================
                    // HASH_COMPUTE Action (for load balancing)
                    // ==========================================
                    ACTION_HASH_COMPUTE: begin
                        if (ENABLE_HASH) begin
                            // Write hash to metadata[31:0] (first 32 bits)
                            metadata_reg[31:0] = flow_hash;
                            
                            // Use hash to select egress port
                            egress_port = flow_hash[8:0];  // Bottom 9 bits
                            
                            drop = 1'b0;
                            header_modified = 1'b0;
                        end
                    end
                    
                    // ==========================================
                    // SET_FIELD Action (for QoS)
                    // ==========================================
                    ACTION_SET_FIELD: begin
                        if (ENABLE_SET_FIELD) begin
                            // action_data layout for SET_FIELD:
                            // [7:0]   = field_id (which field to modify)
                            // [15:8]  = field_value (value to set)
                            
                            automatic logic [7:0] field_id;
                            automatic logic [7:0] field_value;
                            
                            field_id = action_data[7:0];
                            field_value = action_data[15:8];
                            
                            case (field_id)
                                8'd0: begin  // FIELD_DIFFSERV
                                    ipv4_diffserv_out = field_value[5:0];
                                    header_modified = 1'b1;
                                end
                                8'd1: begin  // FIELD_ECN
                                    ipv4_ecn_out = field_value[1:0];
                                    header_modified = 1'b1;
                                end
                                8'd2: begin  // FIELD_TTL
                                    ipv4_ttl_out = field_value;
                                    header_modified = 1'b1;
                                end
                                default: begin
                                    // Unknown field, pass through
                                    header_modified = 1'b0;
                                end
                            endcase
                            
                            drop = 1'b0;
                            egress_port = 9'd0;  // No egress port change
                        end
                    end

                    default: begin
                        // Unknown action: drop for safety
                        drop = 1'b1;
                    end
                endcase
                
                // ============================================
                // STAGE 2: EGRESS PROCESSING
                // ============================================
                
                egress_packet = ingress_packet;  // Default: pass through
                ecn_marked    = 1'b0;
                
                // Only process if egress is enabled and packet not dropped
                if (ENABLE_EGRESS && !drop && ipv4_valid) begin
                    
                    // ------------------------------------------
                    // ECN MARKING LOGIC
                    // ------------------------------------------
                    if (ENABLE_ECN_MARKING) begin
                        // Use input ECN bits
                        ecn_bits = ipv4_ecn_in;
                        
                        // Check if ECN-capable transport (ECT)
                        if (ecn_bits == 2'b01 || ecn_bits == 2'b10) begin
                            // Check if queue is experiencing congestion
                            if (enq_qdepth >= ECN_THRESHOLD) begin
                                // Mark Congestion Experienced (CE)
                                ipv4_ecn_out    = 2'b11;
                                header_modified = 1'b1;
                                ecn_marked      = 1'b1;
                            end
                        end
                    end
                    
                    // ------------------------------------------
                    // MIRRORING LOGIC (placeholder)
                    // ------------------------------------------
                    if (ENABLE_MIRRORING) begin
                        // Future: Clone packet to mirror port
                    end
                end
                
                // Output final packet
                packet_out = egress_packet;
                metadata_out = metadata_reg;
            end
        end
    end

endmodule

// hash.sv
// Hardware hash computation module
// Supports CRC16, CRC32, and XOR hashing for load balancing and flow identification

module hash #(
    parameter HASH_TYPE = 0,     // 0=CRC16, 1=CRC32, 2=XOR
    parameter INPUT_WIDTH = 104, // 5-tuple = 104 bits (default)
    parameter OUTPUT_WIDTH = 16  // Output hash width
) (
    input  wire                        aclk,
    input  wire                        aresetn,
    
    // Input data interface
    input  wire [INPUT_WIDTH-1:0]      data_in,
    input  wire                        valid_in,
    output wire                        ready_out,
    
    // Output hash interface
    output reg  [OUTPUT_WIDTH-1:0]     hash_out,
    output reg                         valid_out
);

    // ==========================================
    // CRC Polynomials
    // ==========================================
    // CRC16-CCITT: x^16 + x^12 + x^5 + 1
    localparam [15:0] CRC16_POLY = 16'h1021;
    
    // CRC32-Ethernet: x^32 + x^26 + x^23 + ... + x^2 + x + 1
    localparam [31:0] CRC32_POLY = 32'h04C11DB7;
    
    // ==========================================
    // Hash Type Generation
    // ==========================================
    generate
        // ==========================================
        // CRC16 Hash (Optimized for Synthesis)
        // ==========================================
        if (HASH_TYPE == 0) begin : gen_crc16
            
            // Internal CRC register
            reg [15:0] crc_reg;
            
            // Sequential CRC computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    crc_reg   <= 16'hFFFF;
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    // Compute CRC in one cycle using function
                    crc_reg   <= compute_crc16(data_in);
                    hash_out  <= compute_crc16(data_in)[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // CRC16 Computation Function (Byte-wise)
            // Processes 8 bits at a time for better timing
            // ==========================================
            function [15:0] compute_crc16(input [INPUT_WIDTH-1:0] data);
                reg [15:0] crc;
                reg [15:0] crc_next;
                reg [7:0] data_byte;
                integer byte_idx, bit_idx;
                integer num_bytes;
                begin
                    // Initialize CRC
                    crc = 16'hFFFF;
                    num_bytes = (INPUT_WIDTH + 7) / 8;
                    
                    // Process each byte
                    for (byte_idx = 0; byte_idx < num_bytes; byte_idx = byte_idx + 1) begin
                        // Extract byte (handle partial last byte)
                        if ((byte_idx + 1) * 8 <= INPUT_WIDTH) begin
                            data_byte = data[byte_idx*8 +: 8];
                        end else begin
                            // Last partial byte - pad with zeros
                            data_byte = {data[INPUT_WIDTH-1 : byte_idx*8], 
                                       {(8-(INPUT_WIDTH % 8)){1'b0}}};
                        end
                        
                        // XOR byte into CRC
                        crc_next = crc ^ {data_byte, 8'h00};
                        
                        // Process each bit using polynomial division
                        for (bit_idx = 0; bit_idx < 8; bit_idx = bit_idx + 1) begin
                            if (crc_next[15]) begin
                                crc_next = {crc_next[14:0], 1'b0} ^ CRC16_POLY;
                            end else begin
                                crc_next = {crc_next[14:0], 1'b0};
                            end
                        end
                        
                        crc = crc_next;
                    end
                    
                    compute_crc16 = ~crc;  // Final XOR (standard practice)
                end
            endfunction
            
        // ==========================================
        // CRC32 Hash (Optimized for Synthesis)
        // ==========================================
        end else if (HASH_TYPE == 1) begin : gen_crc32
            
            // Internal CRC register
            reg [31:0] crc_reg;
            
            // Sequential CRC computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    crc_reg   <= 32'hFFFFFFFF;
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    // Compute CRC in one cycle using function
                    crc_reg   <= compute_crc32(data_in);
                    hash_out  <= compute_crc32(data_in)[OUTPUT_WIDTH-1:0];
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // CRC32 Computation Function (Byte-wise)
            // ==========================================
            function [31:0] compute_crc32(input [INPUT_WIDTH-1:0] data);
                reg [31:0] crc;
                reg [31:0] crc_next;
                reg [7:0] data_byte;
                integer byte_idx, bit_idx;
                integer num_bytes;
                begin
                    // Initialize CRC
                    crc = 32'hFFFFFFFF;
                    num_bytes = (INPUT_WIDTH + 7) / 8;
                    
                    // Process each byte
                    for (byte_idx = 0; byte_idx < num_bytes; byte_idx = byte_idx + 1) begin
                        // Extract byte (handle partial last byte)
                        if ((byte_idx + 1) * 8 <= INPUT_WIDTH) begin
                            data_byte = data[byte_idx*8 +: 8];
                        end else begin
                            // Last partial byte - pad with zeros
                            data_byte = {data[INPUT_WIDTH-1 : byte_idx*8], 
                                       {(8-(INPUT_WIDTH % 8)){1'b0}}};
                        end
                        
                        // XOR byte into CRC (reflected input)
                        crc_next = crc ^ {24'h000000, data_byte};
                        
                        // Process each bit using polynomial division
                        for (bit_idx = 0; bit_idx < 8; bit_idx = bit_idx + 1) begin
                            if (crc_next[0]) begin
                                crc_next = {1'b0, crc_next[31:1]} ^ CRC32_POLY;
                            end else begin
                                crc_next = {1'b0, crc_next[31:1]};
                            end
                        end
                        
                        crc = crc_next;
                    end
                    
                    compute_crc32 = ~crc;  // Final XOR
                end
            endfunction
            
        // ==========================================
        // XOR Hash (Simplest, Fastest)
        // ==========================================
        end else begin : gen_xor
            
            // Sequential XOR computation
            always_ff @(posedge aclk) begin
                if (!aresetn) begin
                    hash_out  <= {OUTPUT_WIDTH{1'b0}};
                    valid_out <= 1'b0;
                end else if (valid_in) begin
                    hash_out  <= xor_reduce(data_in);
                    valid_out <= 1'b1;
                end else begin
                    valid_out <= 1'b0;
                end
            end
            
            // ==========================================
            // XOR Reduction Function
            // Folds all input bits into OUTPUT_WIDTH bits
            // ==========================================
            function [OUTPUT_WIDTH-1:0] xor_reduce(input [INPUT_WIDTH-1:0] data);
                reg [OUTPUT_WIDTH-1:0] result;
                integer i;
                begin
                    result = {OUTPUT_WIDTH{1'b0}};
                    
                    // XOR all input bits into output width buckets
                    for (i = 0; i < INPUT_WIDTH; i = i + 1) begin
                        result[i % OUTPUT_WIDTH] = result[i % OUTPUT_WIDTH] ^ data[i];
                    end
                    
                    xor_reduce = result;
                end
            endfunction
            
        end
    endgenerate
    
    // ==========================================
    // Always ready (single-cycle operation)
    // ==========================================
    assign ready_out = 1'b1;

endmodule